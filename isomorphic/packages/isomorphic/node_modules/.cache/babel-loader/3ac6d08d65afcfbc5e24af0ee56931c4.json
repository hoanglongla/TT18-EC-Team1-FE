{"ast":null,"code":"'use strict';\n/**\n * Module containing the functions to serialize and deserialize\n * {SearchParameters} in the query string format\n * @module algoliasearchHelper.url\n */\n\nvar shortener = require('./SearchParameters/shortener');\n\nvar SearchParameters = require('./SearchParameters');\n\nvar qs = require('qs');\n\nvar bind = require('lodash/bind');\n\nvar forEach = require('lodash/forEach');\n\nvar pick = require('lodash/pick');\n\nvar map = require('lodash/map');\n\nvar mapKeys = require('lodash/mapKeys');\n\nvar mapValues = require('lodash/mapValues');\n\nvar isString = require('lodash/isString');\n\nvar isPlainObject = require('lodash/isPlainObject');\n\nvar isEmpty = require('lodash/isEmpty');\n\nvar invert = require('lodash/invert');\n\nvar encode = require('qs/lib/utils').encode;\n\nfunction recursiveEncode(input) {\n  if (isPlainObject(input)) {\n    return mapValues(input, recursiveEncode);\n  }\n\n  if (Array.isArray(input)) {\n    return map(input, recursiveEncode);\n  }\n\n  if (isString(input)) {\n    return encode(input);\n  }\n\n  return input;\n}\n\nvar refinementsParameters = ['dFR', 'fR', 'nR', 'hFR', 'tR'];\nvar stateKeys = shortener.ENCODED_PARAMETERS;\n\nfunction sortQueryStringValues(prefixRegexp, invertedMapping, a, b) {\n  if (prefixRegexp !== null) {\n    a = a.replace(prefixRegexp, '');\n    b = b.replace(prefixRegexp, '');\n  }\n\n  a = invertedMapping[a] || a;\n  b = invertedMapping[b] || b;\n\n  if (stateKeys.indexOf(a) !== -1 || stateKeys.indexOf(b) !== -1) {\n    if (a === 'q') return -1;\n    if (b === 'q') return 1;\n    var isARefinements = refinementsParameters.indexOf(a) !== -1;\n    var isBRefinements = refinementsParameters.indexOf(b) !== -1;\n\n    if (isARefinements && !isBRefinements) {\n      return 1;\n    } else if (isBRefinements && !isARefinements) {\n      return -1;\n    }\n  }\n\n  return a.localeCompare(b);\n}\n/**\n * Read a query string and return an object containing the state\n * @param {string} queryString the query string that will be decoded\n * @param {object} [options] accepted options :\n *   - prefix : the prefix used for the saved attributes, you have to provide the\n *     same that was used for serialization\n *   - mapping : map short attributes to another value e.g. {q: 'query'}\n * @return {object} partial search parameters object (same properties than in the\n * SearchParameters but not exhaustive)\n */\n\n\nexports.getStateFromQueryString = function (queryString, options) {\n  var prefixForParameters = options && options.prefix || '';\n  var mapping = options && options.mapping || {};\n  var invertedMapping = invert(mapping);\n  var partialStateWithPrefix = qs.parse(queryString);\n  var prefixRegexp = new RegExp('^' + prefixForParameters);\n  var partialState = mapKeys(partialStateWithPrefix, function (v, k) {\n    var hasPrefix = prefixForParameters && prefixRegexp.test(k);\n    var unprefixedKey = hasPrefix ? k.replace(prefixRegexp, '') : k;\n    var decodedKey = shortener.decode(invertedMapping[unprefixedKey] || unprefixedKey);\n    return decodedKey || unprefixedKey;\n  });\n\n  var partialStateWithParsedNumbers = SearchParameters._parseNumbers(partialState);\n\n  return pick(partialStateWithParsedNumbers, SearchParameters.PARAMETERS);\n};\n/**\n * Retrieve an object of all the properties that are not understandable as helper\n * parameters.\n * @param {string} queryString the query string to read\n * @param {object} [options] the options\n *   - prefixForParameters : prefix used for the helper configuration keys\n *   - mapping : map short attributes to another value e.g. {q: 'query'}\n * @return {object} the object containing the parsed configuration that doesn't\n * to the helper\n */\n\n\nexports.getUnrecognizedParametersInQueryString = function (queryString, options) {\n  var prefixForParameters = options && options.prefix;\n  var mapping = options && options.mapping || {};\n  var invertedMapping = invert(mapping);\n  var foreignConfig = {};\n  var config = qs.parse(queryString);\n\n  if (prefixForParameters) {\n    var prefixRegexp = new RegExp('^' + prefixForParameters);\n    forEach(config, function (v, key) {\n      if (!prefixRegexp.test(key)) foreignConfig[key] = v;\n    });\n  } else {\n    forEach(config, function (v, key) {\n      if (!shortener.decode(invertedMapping[key] || key)) foreignConfig[key] = v;\n    });\n  }\n\n  return foreignConfig;\n};\n/**\n * Generate a query string for the state passed according to the options\n * @param {SearchParameters} state state to serialize\n * @param {object} [options] May contain the following parameters :\n *  - prefix : prefix in front of the keys\n *  - mapping : map short attributes to another value e.g. {q: 'query'}\n *  - moreAttributes : more values to be added in the query string. Those values\n *    won't be prefixed.\n *  - safe : get safe urls for use in emails, chat apps or any application auto linking urls.\n *  All parameters and values will be encoded in a way that it's safe to share them.\n *  Default to false for legacy reasons ()\n * @return {string} the query string\n */\n\n\nexports.getQueryStringFromState = function (state, options) {\n  var moreAttributes = options && options.moreAttributes;\n  var prefixForParameters = options && options.prefix || '';\n  var mapping = options && options.mapping || {};\n  var safe = options && options.safe || false;\n  var invertedMapping = invert(mapping);\n  var stateForUrl = safe ? state : recursiveEncode(state);\n  var encodedState = mapKeys(stateForUrl, function (v, k) {\n    var shortK = shortener.encode(k);\n    return prefixForParameters + (mapping[shortK] || shortK);\n  });\n  var prefixRegexp = prefixForParameters === '' ? null : new RegExp('^' + prefixForParameters);\n  var sort = bind(sortQueryStringValues, null, prefixRegexp, invertedMapping);\n\n  if (!isEmpty(moreAttributes)) {\n    var stateQs = qs.stringify(encodedState, {\n      encode: safe,\n      sort: sort\n    });\n    var moreQs = qs.stringify(moreAttributes, {\n      encode: safe\n    });\n    if (!stateQs) return moreQs;\n    return stateQs + '&' + moreQs;\n  }\n\n  return qs.stringify(encodedState, {\n    encode: safe,\n    sort: sort\n  });\n};","map":{"version":3,"sources":["D:/TT18-EC-Team1-FE/isomorphic/node_modules/algoliasearch-helper/src/url.js"],"names":["shortener","require","SearchParameters","qs","bind","forEach","pick","map","mapKeys","mapValues","isString","isPlainObject","isEmpty","invert","encode","recursiveEncode","input","Array","isArray","refinementsParameters","stateKeys","ENCODED_PARAMETERS","sortQueryStringValues","prefixRegexp","invertedMapping","a","b","replace","indexOf","isARefinements","isBRefinements","localeCompare","exports","getStateFromQueryString","queryString","options","prefixForParameters","prefix","mapping","partialStateWithPrefix","parse","RegExp","partialState","v","k","hasPrefix","test","unprefixedKey","decodedKey","decode","partialStateWithParsedNumbers","_parseNumbers","PARAMETERS","getUnrecognizedParametersInQueryString","foreignConfig","config","key","getQueryStringFromState","state","moreAttributes","safe","stateForUrl","encodedState","shortK","sort","stateQs","stringify","moreQs"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Module containing the functions to serialize and deserialize\n * {SearchParameters} in the query string format\n * @module algoliasearchHelper.url\n */\n\nvar shortener = require('./SearchParameters/shortener');\nvar SearchParameters = require('./SearchParameters');\n\nvar qs = require('qs');\n\nvar bind = require('lodash/bind');\nvar forEach = require('lodash/forEach');\nvar pick = require('lodash/pick');\nvar map = require('lodash/map');\nvar mapKeys = require('lodash/mapKeys');\nvar mapValues = require('lodash/mapValues');\nvar isString = require('lodash/isString');\nvar isPlainObject = require('lodash/isPlainObject');\nvar isEmpty = require('lodash/isEmpty');\nvar invert = require('lodash/invert');\n\nvar encode = require('qs/lib/utils').encode;\n\nfunction recursiveEncode(input) {\n  if (isPlainObject(input)) {\n    return mapValues(input, recursiveEncode);\n  }\n  if (Array.isArray(input)) {\n    return map(input, recursiveEncode);\n  }\n  if (isString(input)) {\n    return encode(input);\n  }\n  return input;\n}\n\nvar refinementsParameters = ['dFR', 'fR', 'nR', 'hFR', 'tR'];\nvar stateKeys = shortener.ENCODED_PARAMETERS;\nfunction sortQueryStringValues(prefixRegexp, invertedMapping, a, b) {\n  if (prefixRegexp !== null) {\n    a = a.replace(prefixRegexp, '');\n    b = b.replace(prefixRegexp, '');\n  }\n\n  a = invertedMapping[a] || a;\n  b = invertedMapping[b] || b;\n\n  if (stateKeys.indexOf(a) !== -1 || stateKeys.indexOf(b) !== -1) {\n    if (a === 'q') return -1;\n    if (b === 'q') return 1;\n\n    var isARefinements = refinementsParameters.indexOf(a) !== -1;\n    var isBRefinements = refinementsParameters.indexOf(b) !== -1;\n    if (isARefinements && !isBRefinements) {\n      return 1;\n    } else if (isBRefinements && !isARefinements) {\n      return -1;\n    }\n  }\n\n  return a.localeCompare(b);\n}\n\n/**\n * Read a query string and return an object containing the state\n * @param {string} queryString the query string that will be decoded\n * @param {object} [options] accepted options :\n *   - prefix : the prefix used for the saved attributes, you have to provide the\n *     same that was used for serialization\n *   - mapping : map short attributes to another value e.g. {q: 'query'}\n * @return {object} partial search parameters object (same properties than in the\n * SearchParameters but not exhaustive)\n */\nexports.getStateFromQueryString = function(queryString, options) {\n  var prefixForParameters = options && options.prefix || '';\n  var mapping = options && options.mapping || {};\n  var invertedMapping = invert(mapping);\n\n  var partialStateWithPrefix = qs.parse(queryString);\n  var prefixRegexp = new RegExp('^' + prefixForParameters);\n  var partialState = mapKeys(\n    partialStateWithPrefix,\n    function(v, k) {\n      var hasPrefix = prefixForParameters && prefixRegexp.test(k);\n      var unprefixedKey = hasPrefix ? k.replace(prefixRegexp, '') : k;\n      var decodedKey = shortener.decode(invertedMapping[unprefixedKey] || unprefixedKey);\n      return decodedKey || unprefixedKey;\n    }\n  );\n\n  var partialStateWithParsedNumbers = SearchParameters._parseNumbers(partialState);\n\n  return pick(partialStateWithParsedNumbers, SearchParameters.PARAMETERS);\n};\n\n/**\n * Retrieve an object of all the properties that are not understandable as helper\n * parameters.\n * @param {string} queryString the query string to read\n * @param {object} [options] the options\n *   - prefixForParameters : prefix used for the helper configuration keys\n *   - mapping : map short attributes to another value e.g. {q: 'query'}\n * @return {object} the object containing the parsed configuration that doesn't\n * to the helper\n */\nexports.getUnrecognizedParametersInQueryString = function(queryString, options) {\n  var prefixForParameters = options && options.prefix;\n  var mapping = options && options.mapping || {};\n  var invertedMapping = invert(mapping);\n\n  var foreignConfig = {};\n  var config = qs.parse(queryString);\n  if (prefixForParameters) {\n    var prefixRegexp = new RegExp('^' + prefixForParameters);\n    forEach(config, function(v, key) {\n      if (!prefixRegexp.test(key)) foreignConfig[key] = v;\n    });\n  } else {\n    forEach(config, function(v, key) {\n      if (!shortener.decode(invertedMapping[key] || key)) foreignConfig[key] = v;\n    });\n  }\n\n  return foreignConfig;\n};\n\n/**\n * Generate a query string for the state passed according to the options\n * @param {SearchParameters} state state to serialize\n * @param {object} [options] May contain the following parameters :\n *  - prefix : prefix in front of the keys\n *  - mapping : map short attributes to another value e.g. {q: 'query'}\n *  - moreAttributes : more values to be added in the query string. Those values\n *    won't be prefixed.\n *  - safe : get safe urls for use in emails, chat apps or any application auto linking urls.\n *  All parameters and values will be encoded in a way that it's safe to share them.\n *  Default to false for legacy reasons ()\n * @return {string} the query string\n */\nexports.getQueryStringFromState = function(state, options) {\n  var moreAttributes = options && options.moreAttributes;\n  var prefixForParameters = options && options.prefix || '';\n  var mapping = options && options.mapping || {};\n  var safe = options && options.safe || false;\n  var invertedMapping = invert(mapping);\n\n  var stateForUrl = safe ? state : recursiveEncode(state);\n\n  var encodedState = mapKeys(\n    stateForUrl,\n    function(v, k) {\n      var shortK = shortener.encode(k);\n      return prefixForParameters + (mapping[shortK] || shortK);\n    }\n  );\n\n  var prefixRegexp = prefixForParameters === '' ? null : new RegExp('^' + prefixForParameters);\n  var sort = bind(sortQueryStringValues, null, prefixRegexp, invertedMapping);\n  if (!isEmpty(moreAttributes)) {\n    var stateQs = qs.stringify(encodedState, {encode: safe, sort: sort});\n    var moreQs = qs.stringify(moreAttributes, {encode: safe});\n    if (!stateQs) return moreQs;\n    return stateQs + '&' + moreQs;\n  }\n\n  return qs.stringify(encodedState, {encode: safe, sort: sort});\n};\n"]},"metadata":{},"sourceType":"script"}