{"ast":null,"code":"'use strict';\n\nvar keys = require('lodash/keys');\n\nvar intersection = require('lodash/intersection');\n\nvar forOwn = require('lodash/forOwn');\n\nvar forEach = require('lodash/forEach');\n\nvar filter = require('lodash/filter');\n\nvar map = require('lodash/map');\n\nvar reduce = require('lodash/reduce');\n\nvar omit = require('lodash/omit');\n\nvar indexOf = require('lodash/indexOf');\n\nvar isNaN = require('lodash/isNaN');\n\nvar isEmpty = require('lodash/isEmpty');\n\nvar isEqual = require('lodash/isEqual');\n\nvar isUndefined = require('lodash/isUndefined');\n\nvar isString = require('lodash/isString');\n\nvar isFunction = require('lodash/isFunction');\n\nvar find = require('lodash/find');\n\nvar trim = require('lodash/trim');\n\nvar defaults = require('lodash/defaults');\n\nvar merge = require('lodash/merge');\n\nvar valToNumber = require('../functions/valToNumber');\n\nvar filterState = require('./filterState');\n\nvar RefinementList = require('./RefinementList');\n/**\n * like _.find but using _.isEqual to be able to use it\n * to find arrays.\n * @private\n * @param {any[]} array array to search into\n * @param {any} searchedValue the value we're looking for\n * @return {any} the searched value or undefined\n */\n\n\nfunction findArray(array, searchedValue) {\n  return find(array, function (currentValue) {\n    return isEqual(currentValue, searchedValue);\n  });\n}\n/**\n * The facet list is the structure used to store the list of values used to\n * filter a single attribute.\n * @typedef {string[]} SearchParameters.FacetList\n */\n\n/**\n * Structure to store numeric filters with the operator as the key. The supported operators\n * are `=`, `>`, `<`, `>=`, `<=` and `!=`.\n * @typedef {Object.<string, Array.<number|number[]>>} SearchParameters.OperatorList\n */\n\n/**\n * SearchParameters is the data structure that contains all the information\n * usable for making a search to Algolia API. It doesn't do the search itself,\n * nor does it contains logic about the parameters.\n * It is an immutable object, therefore it has been created in a way that each\n * changes does not change the object itself but returns a copy with the\n * modification.\n * This object should probably not be instantiated outside of the helper. It will\n * be provided when needed. This object is documented for reference as you'll\n * get it from events generated by the {@link AlgoliaSearchHelper}.\n * If need be, instantiate the Helper from the factory function {@link SearchParameters.make}\n * @constructor\n * @classdesc contains all the parameters of a search\n * @param {object|SearchParameters} newParameters existing parameters or partial object\n * for the properties of a new SearchParameters\n * @see SearchParameters.make\n * @example <caption>SearchParameters of the first query in\n *   <a href=\"http://demos.algolia.com/instant-search-demo/\">the instant search demo</a></caption>\n{\n   \"query\": \"\",\n   \"disjunctiveFacets\": [\n      \"customerReviewCount\",\n      \"category\",\n      \"salePrice_range\",\n      \"manufacturer\"\n  ],\n   \"maxValuesPerFacet\": 30,\n   \"page\": 0,\n   \"hitsPerPage\": 10,\n   \"facets\": [\n      \"type\",\n      \"shipping\"\n  ]\n}\n */\n\n\nfunction SearchParameters(newParameters) {\n  var params = newParameters ? SearchParameters._parseNumbers(newParameters) : {};\n  /**\n   * Targeted index. This parameter is mandatory.\n   * @member {string}\n   */\n\n  this.index = params.index || ''; // Query\n\n  /**\n   * Query string of the instant search. The empty string is a valid query.\n   * @member {string}\n   * @see https://www.algolia.com/doc/rest#param-query\n   */\n\n  this.query = params.query || ''; // Facets\n\n  /**\n   * This attribute contains the list of all the conjunctive facets\n   * used. This list will be added to requested facets in the\n   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.\n   * @member {string[]}\n   */\n\n  this.facets = params.facets || [];\n  /**\n   * This attribute contains the list of all the disjunctive facets\n   * used. This list will be added to requested facets in the\n   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.\n   * @member {string[]}\n   */\n\n  this.disjunctiveFacets = params.disjunctiveFacets || [];\n  /**\n   * This attribute contains the list of all the hierarchical facets\n   * used. This list will be added to requested facets in the\n   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.\n   * Hierarchical facets are a sub type of disjunctive facets that\n   * let you filter faceted attributes hierarchically.\n   * @member {string[]|object[]}\n   */\n\n  this.hierarchicalFacets = params.hierarchicalFacets || []; // Refinements\n\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the conjunctive facets. Each facet must be properly\n   * defined in the `facets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters selected for the associated facet name.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n\n  this.facetsRefinements = params.facetsRefinements || {};\n  /**\n   * This attribute contains all the filters that need to be\n   * excluded from the conjunctive facets. Each facet must be properly\n   * defined in the `facets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters excluded for the associated facet name.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n\n  this.facetsExcludes = params.facetsExcludes || {};\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the disjunctive facets. Each facet must be properly\n   * defined in the `disjunctiveFacets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters selected for the associated facet name.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n\n  this.disjunctiveFacetsRefinements = params.disjunctiveFacetsRefinements || {};\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the numeric attributes.\n   *\n   * The key is the name of the attribute, and the value is the\n   * filters to apply to this attribute.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `numericFilters` attribute.\n   * @member {Object.<string, SearchParameters.OperatorList>}\n   */\n\n  this.numericRefinements = params.numericRefinements || {};\n  /**\n   * This attribute contains all the tags used to refine the query.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `tagFilters` attribute.\n   * @member {string[]}\n   */\n\n  this.tagRefinements = params.tagRefinements || [];\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the hierarchical facets. Each facet must be properly\n   * defined in the `hierarchicalFacets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters selected for the associated facet name. The FacetList values\n   * are structured as a string that contain the values for each level\n   * separated by the configured separator.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n\n  this.hierarchicalFacetsRefinements = params.hierarchicalFacetsRefinements || {};\n  /**\n   * Contains the numeric filters in the raw format of the Algolia API. Setting\n   * this parameter is not compatible with the usage of numeric filters methods.\n   * @see https://www.algolia.com/doc/javascript#numericFilters\n   * @member {string}\n   */\n\n  this.numericFilters = params.numericFilters;\n  /**\n   * Contains the tag filters in the raw format of the Algolia API. Setting this\n   * parameter is not compatible with the of the add/remove/toggle methods of the\n   * tag api.\n   * @see https://www.algolia.com/doc/rest#param-tagFilters\n   * @member {string}\n   */\n\n  this.tagFilters = params.tagFilters;\n  /**\n   * Contains the optional tag filters in the raw format of the Algolia API.\n   * @see https://www.algolia.com/doc/rest#param-tagFilters\n   * @member {string}\n   */\n\n  this.optionalTagFilters = params.optionalTagFilters;\n  /**\n   * Contains the optional facet filters in the raw format of the Algolia API.\n   * @see https://www.algolia.com/doc/rest#param-tagFilters\n   * @member {string}\n   */\n\n  this.optionalFacetFilters = params.optionalFacetFilters; // Misc. parameters\n\n  /**\n   * Number of hits to be returned by the search API\n   * @member {number}\n   * @see https://www.algolia.com/doc/rest#param-hitsPerPage\n   */\n\n  this.hitsPerPage = params.hitsPerPage;\n  /**\n   * Number of values for each faceted attribute\n   * @member {number}\n   * @see https://www.algolia.com/doc/rest#param-maxValuesPerFacet\n   */\n\n  this.maxValuesPerFacet = params.maxValuesPerFacet;\n  /**\n   * The current page number\n   * @member {number}\n   * @see https://www.algolia.com/doc/rest#param-page\n   */\n\n  this.page = params.page || 0;\n  /**\n   * How the query should be treated by the search engine.\n   * Possible values: prefixAll, prefixLast, prefixNone\n   * @see https://www.algolia.com/doc/rest#param-queryType\n   * @member {string}\n   */\n\n  this.queryType = params.queryType;\n  /**\n   * How the typo tolerance behave in the search engine.\n   * Possible values: true, false, min, strict\n   * @see https://www.algolia.com/doc/rest#param-typoTolerance\n   * @member {string}\n   */\n\n  this.typoTolerance = params.typoTolerance;\n  /**\n   * Number of characters to wait before doing one character replacement.\n   * @see https://www.algolia.com/doc/rest#param-minWordSizefor1Typo\n   * @member {number}\n   */\n\n  this.minWordSizefor1Typo = params.minWordSizefor1Typo;\n  /**\n   * Number of characters to wait before doing a second character replacement.\n   * @see https://www.algolia.com/doc/rest#param-minWordSizefor2Typos\n   * @member {number}\n   */\n\n  this.minWordSizefor2Typos = params.minWordSizefor2Typos;\n  /**\n   * Configure the precision of the proximity ranking criterion\n   * @see https://www.algolia.com/doc/rest#param-minProximity\n   */\n\n  this.minProximity = params.minProximity;\n  /**\n   * Should the engine allow typos on numerics.\n   * @see https://www.algolia.com/doc/rest#param-allowTyposOnNumericTokens\n   * @member {boolean}\n   */\n\n  this.allowTyposOnNumericTokens = params.allowTyposOnNumericTokens;\n  /**\n   * Should the plurals be ignored\n   * @see https://www.algolia.com/doc/rest#param-ignorePlurals\n   * @member {boolean}\n   */\n\n  this.ignorePlurals = params.ignorePlurals;\n  /**\n   * Restrict which attribute is searched.\n   * @see https://www.algolia.com/doc/rest#param-restrictSearchableAttributes\n   * @member {string}\n   */\n\n  this.restrictSearchableAttributes = params.restrictSearchableAttributes;\n  /**\n   * Enable the advanced syntax.\n   * @see https://www.algolia.com/doc/rest#param-advancedSyntax\n   * @member {boolean}\n   */\n\n  this.advancedSyntax = params.advancedSyntax;\n  /**\n   * Enable the analytics\n   * @see https://www.algolia.com/doc/rest#param-analytics\n   * @member {boolean}\n   */\n\n  this.analytics = params.analytics;\n  /**\n   * Tag of the query in the analytics.\n   * @see https://www.algolia.com/doc/rest#param-analyticsTags\n   * @member {string}\n   */\n\n  this.analyticsTags = params.analyticsTags;\n  /**\n   * Enable the synonyms\n   * @see https://www.algolia.com/doc/rest#param-synonyms\n   * @member {boolean}\n   */\n\n  this.synonyms = params.synonyms;\n  /**\n   * Should the engine replace the synonyms in the highlighted results.\n   * @see https://www.algolia.com/doc/rest#param-replaceSynonymsInHighlight\n   * @member {boolean}\n   */\n\n  this.replaceSynonymsInHighlight = params.replaceSynonymsInHighlight;\n  /**\n   * Add some optional words to those defined in the dashboard\n   * @see https://www.algolia.com/doc/rest#param-optionalWords\n   * @member {string}\n   */\n\n  this.optionalWords = params.optionalWords;\n  /**\n   * Possible values are \"lastWords\" \"firstWords\" \"allOptional\" \"none\" (default)\n   * @see https://www.algolia.com/doc/rest#param-removeWordsIfNoResults\n   * @member {string}\n   */\n\n  this.removeWordsIfNoResults = params.removeWordsIfNoResults;\n  /**\n   * List of attributes to retrieve\n   * @see https://www.algolia.com/doc/rest#param-attributesToRetrieve\n   * @member {string}\n   */\n\n  this.attributesToRetrieve = params.attributesToRetrieve;\n  /**\n   * List of attributes to highlight\n   * @see https://www.algolia.com/doc/rest#param-attributesToHighlight\n   * @member {string}\n   */\n\n  this.attributesToHighlight = params.attributesToHighlight;\n  /**\n   * Code to be embedded on the left part of the highlighted results\n   * @see https://www.algolia.com/doc/rest#param-highlightPreTag\n   * @member {string}\n   */\n\n  this.highlightPreTag = params.highlightPreTag;\n  /**\n   * Code to be embedded on the right part of the highlighted results\n   * @see https://www.algolia.com/doc/rest#param-highlightPostTag\n   * @member {string}\n   */\n\n  this.highlightPostTag = params.highlightPostTag;\n  /**\n   * List of attributes to snippet\n   * @see https://www.algolia.com/doc/rest#param-attributesToSnippet\n   * @member {string}\n   */\n\n  this.attributesToSnippet = params.attributesToSnippet;\n  /**\n   * Enable the ranking informations in the response, set to 1 to activate\n   * @see https://www.algolia.com/doc/rest#param-getRankingInfo\n   * @member {number}\n   */\n\n  this.getRankingInfo = params.getRankingInfo;\n  /**\n   * Remove duplicates based on the index setting attributeForDistinct\n   * @see https://www.algolia.com/doc/rest#param-distinct\n   * @member {boolean|number}\n   */\n\n  this.distinct = params.distinct;\n  /**\n   * Center of the geo search.\n   * @see https://www.algolia.com/doc/rest#param-aroundLatLng\n   * @member {string}\n   */\n\n  this.aroundLatLng = params.aroundLatLng;\n  /**\n   * Center of the search, retrieve from the user IP.\n   * @see https://www.algolia.com/doc/rest#param-aroundLatLngViaIP\n   * @member {boolean}\n   */\n\n  this.aroundLatLngViaIP = params.aroundLatLngViaIP;\n  /**\n   * Radius of the geo search.\n   * @see https://www.algolia.com/doc/rest#param-aroundRadius\n   * @member {number}\n   */\n\n  this.aroundRadius = params.aroundRadius;\n  /**\n   * Precision of the geo search.\n   * @see https://www.algolia.com/doc/rest#param-aroundPrecision\n   * @member {number}\n   */\n\n  this.minimumAroundRadius = params.minimumAroundRadius;\n  /**\n   * Precision of the geo search.\n   * @see https://www.algolia.com/doc/rest#param-minimumAroundRadius\n   * @member {number}\n   */\n\n  this.aroundPrecision = params.aroundPrecision;\n  /**\n   * Geo search inside a box.\n   * @see https://www.algolia.com/doc/rest#param-insideBoundingBox\n   * @member {string}\n   */\n\n  this.insideBoundingBox = params.insideBoundingBox;\n  /**\n   * Geo search inside a polygon.\n   * @see https://www.algolia.com/doc/rest#param-insidePolygon\n   * @member {string}\n   */\n\n  this.insidePolygon = params.insidePolygon;\n  /**\n   * Allows to specify an ellipsis character for the snippet when we truncate the text\n   * (added before and after if truncated).\n   * The default value is an empty string and we recommend to set it to \"…\"\n   * @see https://www.algolia.com/doc/rest#param-insidePolygon\n   * @member {string}\n   */\n\n  this.snippetEllipsisText = params.snippetEllipsisText;\n  /**\n   * Allows to specify some attributes name on which exact won't be applied.\n   * Attributes are separated with a comma (for example \"name,address\" ), you can also use a\n   * JSON string array encoding (for example encodeURIComponent('[\"name\",\"address\"]') ).\n   * By default the list is empty.\n   * @see https://www.algolia.com/doc/rest#param-disableExactOnAttributes\n   * @member {string|string[]}\n   */\n\n  this.disableExactOnAttributes = params.disableExactOnAttributes;\n  /**\n   * Applies 'exact' on single word queries if the word contains at least 3 characters\n   * and is not a stop word.\n   * Can take two values: true or false.\n   * By default, its set to false.\n   * @see https://www.algolia.com/doc/rest#param-enableExactOnSingleWordQuery\n   * @member {boolean}\n   */\n\n  this.enableExactOnSingleWordQuery = params.enableExactOnSingleWordQuery; // Undocumented parameters, still needed otherwise we fail\n\n  this.offset = params.offset;\n  this.length = params.length;\n  var self = this;\n  forOwn(params, function checkForUnknownParameter(paramValue, paramName) {\n    if (SearchParameters.PARAMETERS.indexOf(paramName) === -1) {\n      self[paramName] = paramValue;\n    }\n  });\n}\n/**\n * List all the properties in SearchParameters and therefore all the known Algolia properties\n * This doesn't contain any beta/hidden features.\n * @private\n */\n\n\nSearchParameters.PARAMETERS = keys(new SearchParameters());\n/**\n * @private\n * @param {object} partialState full or part of a state\n * @return {object} a new object with the number keys as number\n */\n\nSearchParameters._parseNumbers = function (partialState) {\n  // Do not reparse numbers in SearchParameters, they ought to be parsed already\n  if (partialState instanceof SearchParameters) return partialState;\n  var numbers = {};\n  var numberKeys = ['aroundPrecision', 'aroundRadius', 'getRankingInfo', 'minWordSizefor2Typos', 'minWordSizefor1Typo', 'page', 'maxValuesPerFacet', 'distinct', 'minimumAroundRadius', 'hitsPerPage', 'minProximity'];\n  forEach(numberKeys, function (k) {\n    var value = partialState[k];\n\n    if (isString(value)) {\n      var parsedValue = parseFloat(value);\n      numbers[k] = isNaN(parsedValue) ? value : parsedValue;\n    }\n  }); // there's two formats of insideBoundingBox, we need to parse\n  // the one which is an array of float geo rectangles\n\n  if (Array.isArray(partialState.insideBoundingBox)) {\n    numbers.insideBoundingBox = partialState.insideBoundingBox.map(function (geoRect) {\n      return geoRect.map(function (value) {\n        return parseFloat(value);\n      });\n    });\n  }\n\n  if (partialState.numericRefinements) {\n    var numericRefinements = {};\n    forEach(partialState.numericRefinements, function (operators, attribute) {\n      numericRefinements[attribute] = {};\n      forEach(operators, function (values, operator) {\n        var parsedValues = map(values, function (v) {\n          if (Array.isArray(v)) {\n            return map(v, function (vPrime) {\n              if (isString(vPrime)) {\n                return parseFloat(vPrime);\n              }\n\n              return vPrime;\n            });\n          } else if (isString(v)) {\n            return parseFloat(v);\n          }\n\n          return v;\n        });\n        numericRefinements[attribute][operator] = parsedValues;\n      });\n    });\n    numbers.numericRefinements = numericRefinements;\n  }\n\n  return merge({}, partialState, numbers);\n};\n/**\n * Factory for SearchParameters\n * @param {object|SearchParameters} newParameters existing parameters or partial\n * object for the properties of a new SearchParameters\n * @return {SearchParameters} frozen instance of SearchParameters\n */\n\n\nSearchParameters.make = function makeSearchParameters(newParameters) {\n  var instance = new SearchParameters(newParameters);\n  forEach(newParameters.hierarchicalFacets, function (facet) {\n    if (facet.rootPath) {\n      var currentRefinement = instance.getHierarchicalRefinement(facet.name);\n\n      if (currentRefinement.length > 0 && currentRefinement[0].indexOf(facet.rootPath) !== 0) {\n        instance = instance.clearRefinements(facet.name);\n      } // get it again in case it has been cleared\n\n\n      currentRefinement = instance.getHierarchicalRefinement(facet.name);\n\n      if (currentRefinement.length === 0) {\n        instance = instance.toggleHierarchicalFacetRefinement(facet.name, facet.rootPath);\n      }\n    }\n  });\n  return instance;\n};\n/**\n * Validates the new parameters based on the previous state\n * @param {SearchParameters} currentState the current state\n * @param {object|SearchParameters} parameters the new parameters to set\n * @return {Error|null} Error if the modification is invalid, null otherwise\n */\n\n\nSearchParameters.validate = function (currentState, parameters) {\n  var params = parameters || {};\n\n  if (currentState.tagFilters && params.tagRefinements && params.tagRefinements.length > 0) {\n    return new Error('[Tags] Cannot switch from the managed tag API to the advanced API. It is probably ' + 'an error, if it is really what you want, you should first clear the tags with clearTags method.');\n  }\n\n  if (currentState.tagRefinements.length > 0 && params.tagFilters) {\n    return new Error('[Tags] Cannot switch from the advanced tag API to the managed API. It is probably ' + 'an error, if it is not, you should first clear the tags with clearTags method.');\n  }\n\n  if (currentState.numericFilters && params.numericRefinements && !isEmpty(params.numericRefinements)) {\n    return new Error(\"[Numeric filters] Can't switch from the advanced to the managed API. It\" + ' is probably an error, if this is really what you want, you have to first' + ' clear the numeric filters.');\n  }\n\n  if (!isEmpty(currentState.numericRefinements) && params.numericFilters) {\n    return new Error(\"[Numeric filters] Can't switch from the managed API to the advanced. It\" + ' is probably an error, if this is really what you want, you have to first' + ' clear the numeric filters.');\n  }\n\n  return null;\n};\n\nSearchParameters.prototype = {\n  constructor: SearchParameters,\n\n  /**\n   * Remove all refinements (disjunctive + conjunctive + excludes + numeric filters)\n   * @method\n   * @param {undefined|string|SearchParameters.clearCallback} [attribute] optional string or function\n   * - If not given, means to clear all the filters.\n   * - If `string`, means to clear all refinements for the `attribute` named filter.\n   * - If `function`, means to clear all the refinements that return truthy values.\n   * @return {SearchParameters}\n   */\n  clearRefinements: function clearRefinements(attribute) {\n    var clear = RefinementList.clearRefinement;\n    var patch = {\n      numericRefinements: this._clearNumericRefinements(attribute),\n      facetsRefinements: clear(this.facetsRefinements, attribute, 'conjunctiveFacet'),\n      facetsExcludes: clear(this.facetsExcludes, attribute, 'exclude'),\n      disjunctiveFacetsRefinements: clear(this.disjunctiveFacetsRefinements, attribute, 'disjunctiveFacet'),\n      hierarchicalFacetsRefinements: clear(this.hierarchicalFacetsRefinements, attribute, 'hierarchicalFacet')\n    };\n\n    if (patch.numericRefinements === this.numericRefinements && patch.facetsRefinements === this.facetsRefinements && patch.facetsExcludes === this.facetsExcludes && patch.disjunctiveFacetsRefinements === this.disjunctiveFacetsRefinements && patch.hierarchicalFacetsRefinements === this.hierarchicalFacetsRefinements) {\n      return this;\n    }\n\n    return this.setQueryParameters(patch);\n  },\n\n  /**\n   * Remove all the refined tags from the SearchParameters\n   * @method\n   * @return {SearchParameters}\n   */\n  clearTags: function clearTags() {\n    if (this.tagFilters === undefined && this.tagRefinements.length === 0) return this;\n    return this.setQueryParameters({\n      tagFilters: undefined,\n      tagRefinements: []\n    });\n  },\n\n  /**\n   * Set the index.\n   * @method\n   * @param {string} index the index name\n   * @return {SearchParameters}\n   */\n  setIndex: function setIndex(index) {\n    if (index === this.index) return this;\n    return this.setQueryParameters({\n      index: index\n    });\n  },\n\n  /**\n   * Query setter\n   * @method\n   * @param {string} newQuery value for the new query\n   * @return {SearchParameters}\n   */\n  setQuery: function setQuery(newQuery) {\n    if (newQuery === this.query) return this;\n    return this.setQueryParameters({\n      query: newQuery\n    });\n  },\n\n  /**\n   * Page setter\n   * @method\n   * @param {number} newPage new page number\n   * @return {SearchParameters}\n   */\n  setPage: function setPage(newPage) {\n    if (newPage === this.page) return this;\n    return this.setQueryParameters({\n      page: newPage\n    });\n  },\n\n  /**\n   * Facets setter\n   * The facets are the simple facets, used for conjunctive (and) faceting.\n   * @method\n   * @param {string[]} facets all the attributes of the algolia records used for conjunctive faceting\n   * @return {SearchParameters}\n   */\n  setFacets: function setFacets(facets) {\n    return this.setQueryParameters({\n      facets: facets\n    });\n  },\n\n  /**\n   * Disjunctive facets setter\n   * Change the list of disjunctive (or) facets the helper chan handle.\n   * @method\n   * @param {string[]} facets all the attributes of the algolia records used for disjunctive faceting\n   * @return {SearchParameters}\n   */\n  setDisjunctiveFacets: function setDisjunctiveFacets(facets) {\n    return this.setQueryParameters({\n      disjunctiveFacets: facets\n    });\n  },\n\n  /**\n   * HitsPerPage setter\n   * Hits per page represents the number of hits retrieved for this query\n   * @method\n   * @param {number} n number of hits retrieved per page of results\n   * @return {SearchParameters}\n   */\n  setHitsPerPage: function setHitsPerPage(n) {\n    if (this.hitsPerPage === n) return this;\n    return this.setQueryParameters({\n      hitsPerPage: n\n    });\n  },\n\n  /**\n   * typoTolerance setter\n   * Set the value of typoTolerance\n   * @method\n   * @param {string} typoTolerance new value of typoTolerance (\"true\", \"false\", \"min\" or \"strict\")\n   * @return {SearchParameters}\n   */\n  setTypoTolerance: function setTypoTolerance(typoTolerance) {\n    if (this.typoTolerance === typoTolerance) return this;\n    return this.setQueryParameters({\n      typoTolerance: typoTolerance\n    });\n  },\n\n  /**\n   * Add a numeric filter for a given attribute\n   * When value is an array, they are combined with OR\n   * When value is a single value, it will combined with AND\n   * @method\n   * @param {string} attribute attribute to set the filter on\n   * @param {string} operator operator of the filter (possible values: =, >, >=, <, <=, !=)\n   * @param {number | number[]} value value of the filter\n   * @return {SearchParameters}\n   * @example\n   * // for price = 50 or 40\n   * searchparameter.addNumericRefinement('price', '=', [50, 40]);\n   * @example\n   * // for size = 38 and 40\n   * searchparameter.addNumericRefinement('size', '=', 38);\n   * searchparameter.addNumericRefinement('size', '=', 40);\n   */\n  addNumericRefinement: function (attribute, operator, v) {\n    var value = valToNumber(v);\n    if (this.isNumericRefined(attribute, operator, value)) return this;\n    var mod = merge({}, this.numericRefinements);\n    mod[attribute] = merge({}, mod[attribute]);\n\n    if (mod[attribute][operator]) {\n      // Array copy\n      mod[attribute][operator] = mod[attribute][operator].slice(); // Add the element. Concat can't be used here because value can be an array.\n\n      mod[attribute][operator].push(value);\n    } else {\n      mod[attribute][operator] = [value];\n    }\n\n    return this.setQueryParameters({\n      numericRefinements: mod\n    });\n  },\n\n  /**\n   * Get the list of conjunctive refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getConjunctiveRefinements: function (facetName) {\n    if (!this.isConjunctiveFacet(facetName)) {\n      throw new Error(facetName + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    return this.facetsRefinements[facetName] || [];\n  },\n\n  /**\n   * Get the list of disjunctive refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getDisjunctiveRefinements: function (facetName) {\n    if (!this.isDisjunctiveFacet(facetName)) {\n      throw new Error(facetName + ' is not defined in the disjunctiveFacets attribute of the helper configuration');\n    }\n\n    return this.disjunctiveFacetsRefinements[facetName] || [];\n  },\n\n  /**\n   * Get the list of hierarchical refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getHierarchicalRefinement: function (facetName) {\n    // we send an array but we currently do not support multiple\n    // hierarchicalRefinements for a hierarchicalFacet\n    return this.hierarchicalFacetsRefinements[facetName] || [];\n  },\n\n  /**\n   * Get the list of exclude refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getExcludeRefinements: function (facetName) {\n    if (!this.isConjunctiveFacet(facetName)) {\n      throw new Error(facetName + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    return this.facetsExcludes[facetName] || [];\n  },\n\n  /**\n   * Remove all the numeric filter for a given (attribute, operator)\n   * @method\n   * @param {string} attribute attribute to set the filter on\n   * @param {string} [operator] operator of the filter (possible values: =, >, >=, <, <=, !=)\n   * @param {number} [number] the value to be removed\n   * @return {SearchParameters}\n   */\n  removeNumericRefinement: function (attribute, operator, paramValue) {\n    if (paramValue !== undefined) {\n      var paramValueAsNumber = valToNumber(paramValue);\n      if (!this.isNumericRefined(attribute, operator, paramValueAsNumber)) return this;\n      return this.setQueryParameters({\n        numericRefinements: this._clearNumericRefinements(function (value, key) {\n          return key === attribute && value.op === operator && isEqual(value.val, paramValueAsNumber);\n        })\n      });\n    } else if (operator !== undefined) {\n      if (!this.isNumericRefined(attribute, operator)) return this;\n      return this.setQueryParameters({\n        numericRefinements: this._clearNumericRefinements(function (value, key) {\n          return key === attribute && value.op === operator;\n        })\n      });\n    }\n\n    if (!this.isNumericRefined(attribute)) return this;\n    return this.setQueryParameters({\n      numericRefinements: this._clearNumericRefinements(function (value, key) {\n        return key === attribute;\n      })\n    });\n  },\n\n  /**\n   * Get the list of numeric refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {SearchParameters.OperatorList[]} list of refinements\n   */\n  getNumericRefinements: function (facetName) {\n    return this.numericRefinements[facetName] || {};\n  },\n\n  /**\n   * Return the current refinement for the (attribute, operator)\n   * @param {string} attribute attribute in the record\n   * @param {string} operator operator applied on the refined values\n   * @return {Array.<number|number[]>} refined values\n   */\n  getNumericRefinement: function (attribute, operator) {\n    return this.numericRefinements[attribute] && this.numericRefinements[attribute][operator];\n  },\n\n  /**\n   * Clear numeric filters.\n   * @method\n   * @private\n   * @param {string|SearchParameters.clearCallback} [attribute] optional string or function\n   * - If not given, means to clear all the filters.\n   * - If `string`, means to clear all refinements for the `attribute` named filter.\n   * - If `function`, means to clear all the refinements that return truthy values.\n   * @return {Object.<string, OperatorList>}\n   */\n  _clearNumericRefinements: function _clearNumericRefinements(attribute) {\n    if (isUndefined(attribute)) {\n      if (isEmpty(this.numericRefinements)) return this.numericRefinements;\n      return {};\n    } else if (isString(attribute)) {\n      if (isEmpty(this.numericRefinements[attribute])) return this.numericRefinements;\n      return omit(this.numericRefinements, attribute);\n    } else if (isFunction(attribute)) {\n      var hasChanged = false;\n      var newNumericRefinements = reduce(this.numericRefinements, function (memo, operators, key) {\n        var operatorList = {};\n        forEach(operators, function (values, operator) {\n          var outValues = [];\n          forEach(values, function (value) {\n            var predicateResult = attribute({\n              val: value,\n              op: operator\n            }, key, 'numeric');\n            if (!predicateResult) outValues.push(value);\n          });\n\n          if (!isEmpty(outValues)) {\n            if (outValues.length !== values.length) hasChanged = true;\n            operatorList[operator] = outValues;\n          } else hasChanged = true;\n        });\n        if (!isEmpty(operatorList)) memo[key] = operatorList;\n        return memo;\n      }, {});\n      if (hasChanged) return newNumericRefinements;\n      return this.numericRefinements;\n    }\n  },\n\n  /**\n   * Add a facet to the facets attribute of the helper configuration, if it\n   * isn't already present.\n   * @method\n   * @param {string} facet facet name to add\n   * @return {SearchParameters}\n   */\n  addFacet: function addFacet(facet) {\n    if (this.isConjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.setQueryParameters({\n      facets: this.facets.concat([facet])\n    });\n  },\n\n  /**\n   * Add a disjunctive facet to the disjunctiveFacets attribute of the helper\n   * configuration, if it isn't already present.\n   * @method\n   * @param {string} facet disjunctive facet name to add\n   * @return {SearchParameters}\n   */\n  addDisjunctiveFacet: function addDisjunctiveFacet(facet) {\n    if (this.isDisjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.setQueryParameters({\n      disjunctiveFacets: this.disjunctiveFacets.concat([facet])\n    });\n  },\n\n  /**\n   * Add a hierarchical facet to the hierarchicalFacets attribute of the helper\n   * configuration.\n   * @method\n   * @param {object} hierarchicalFacet hierarchical facet to add\n   * @return {SearchParameters}\n   * @throws will throw an error if a hierarchical facet with the same name was already declared\n   */\n  addHierarchicalFacet: function addHierarchicalFacet(hierarchicalFacet) {\n    if (this.isHierarchicalFacet(hierarchicalFacet.name)) {\n      throw new Error('Cannot declare two hierarchical facets with the same name: `' + hierarchicalFacet.name + '`');\n    }\n\n    return this.setQueryParameters({\n      hierarchicalFacets: this.hierarchicalFacets.concat([hierarchicalFacet])\n    });\n  },\n\n  /**\n   * Add a refinement on a \"normal\" facet\n   * @method\n   * @param {string} facet attribute to apply the faceting on\n   * @param {string} value value of the attribute (will be converted to string)\n   * @return {SearchParameters}\n   */\n  addFacetRefinement: function addFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    if (RefinementList.isRefined(this.facetsRefinements, facet, value)) return this;\n    return this.setQueryParameters({\n      facetsRefinements: RefinementList.addRefinement(this.facetsRefinements, facet, value)\n    });\n  },\n\n  /**\n   * Exclude a value from a \"normal\" facet\n   * @method\n   * @param {string} facet attribute to apply the exclusion on\n   * @param {string} value value of the attribute (will be converted to string)\n   * @return {SearchParameters}\n   */\n  addExcludeRefinement: function addExcludeRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    if (RefinementList.isRefined(this.facetsExcludes, facet, value)) return this;\n    return this.setQueryParameters({\n      facetsExcludes: RefinementList.addRefinement(this.facetsExcludes, facet, value)\n    });\n  },\n\n  /**\n   * Adds a refinement on a disjunctive facet.\n   * @method\n   * @param {string} facet attribute to apply the faceting on\n   * @param {string} value value of the attribute (will be converted to string)\n   * @return {SearchParameters}\n   */\n  addDisjunctiveFacetRefinement: function addDisjunctiveFacetRefinement(facet, value) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');\n    }\n\n    if (RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value)) return this;\n    return this.setQueryParameters({\n      disjunctiveFacetsRefinements: RefinementList.addRefinement(this.disjunctiveFacetsRefinements, facet, value)\n    });\n  },\n\n  /**\n   * addTagRefinement adds a tag to the list used to filter the results\n   * @param {string} tag tag to be added\n   * @return {SearchParameters}\n   */\n  addTagRefinement: function addTagRefinement(tag) {\n    if (this.isTagRefined(tag)) return this;\n    var modification = {\n      tagRefinements: this.tagRefinements.concat(tag)\n    };\n    return this.setQueryParameters(modification);\n  },\n\n  /**\n   * Remove a facet from the facets attribute of the helper configuration, if it\n   * is present.\n   * @method\n   * @param {string} facet facet name to remove\n   * @return {SearchParameters}\n   */\n  removeFacet: function removeFacet(facet) {\n    if (!this.isConjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.clearRefinements(facet).setQueryParameters({\n      facets: filter(this.facets, function (f) {\n        return f !== facet;\n      })\n    });\n  },\n\n  /**\n   * Remove a disjunctive facet from the disjunctiveFacets attribute of the\n   * helper configuration, if it is present.\n   * @method\n   * @param {string} facet disjunctive facet name to remove\n   * @return {SearchParameters}\n   */\n  removeDisjunctiveFacet: function removeDisjunctiveFacet(facet) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.clearRefinements(facet).setQueryParameters({\n      disjunctiveFacets: filter(this.disjunctiveFacets, function (f) {\n        return f !== facet;\n      })\n    });\n  },\n\n  /**\n   * Remove a hierarchical facet from the hierarchicalFacets attribute of the\n   * helper configuration, if it is present.\n   * @method\n   * @param {string} facet hierarchical facet name to remove\n   * @return {SearchParameters}\n   */\n  removeHierarchicalFacet: function removeHierarchicalFacet(facet) {\n    if (!this.isHierarchicalFacet(facet)) {\n      return this;\n    }\n\n    return this.clearRefinements(facet).setQueryParameters({\n      hierarchicalFacets: filter(this.hierarchicalFacets, function (f) {\n        return f.name !== facet;\n      })\n    });\n  },\n\n  /**\n   * Remove a refinement set on facet. If a value is provided, it will clear the\n   * refinement for the given value, otherwise it will clear all the refinement\n   * values for the faceted attribute.\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {string} [value] value used to filter\n   * @return {SearchParameters}\n   */\n  removeFacetRefinement: function removeFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    if (!RefinementList.isRefined(this.facetsRefinements, facet, value)) return this;\n    return this.setQueryParameters({\n      facetsRefinements: RefinementList.removeRefinement(this.facetsRefinements, facet, value)\n    });\n  },\n\n  /**\n   * Remove a negative refinement on a facet\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {string} value value used to filter\n   * @return {SearchParameters}\n   */\n  removeExcludeRefinement: function removeExcludeRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    if (!RefinementList.isRefined(this.facetsExcludes, facet, value)) return this;\n    return this.setQueryParameters({\n      facetsExcludes: RefinementList.removeRefinement(this.facetsExcludes, facet, value)\n    });\n  },\n\n  /**\n   * Remove a refinement on a disjunctive facet\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {string} value value used to filter\n   * @return {SearchParameters}\n   */\n  removeDisjunctiveFacetRefinement: function removeDisjunctiveFacetRefinement(facet, value) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');\n    }\n\n    if (!RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value)) return this;\n    return this.setQueryParameters({\n      disjunctiveFacetsRefinements: RefinementList.removeRefinement(this.disjunctiveFacetsRefinements, facet, value)\n    });\n  },\n\n  /**\n   * Remove a tag from the list of tag refinements\n   * @method\n   * @param {string} tag the tag to remove\n   * @return {SearchParameters}\n   */\n  removeTagRefinement: function removeTagRefinement(tag) {\n    if (!this.isTagRefined(tag)) return this;\n    var modification = {\n      tagRefinements: filter(this.tagRefinements, function (t) {\n        return t !== tag;\n      })\n    };\n    return this.setQueryParameters(modification);\n  },\n\n  /**\n   * Generic toggle refinement method to use with facet, disjunctive facets\n   * and hierarchical facets\n   * @param  {string} facet the facet to refine\n   * @param  {string} value the associated value\n   * @return {SearchParameters}\n   * @throws will throw an error if the facet is not declared in the settings of the helper\n   * @deprecated since version 2.19.0, see {@link SearchParameters#toggleFacetRefinement}\n   */\n  toggleRefinement: function toggleRefinement(facet, value) {\n    return this.toggleFacetRefinement(facet, value);\n  },\n\n  /**\n   * Generic toggle refinement method to use with facet, disjunctive facets\n   * and hierarchical facets\n   * @param  {string} facet the facet to refine\n   * @param  {string} value the associated value\n   * @return {SearchParameters}\n   * @throws will throw an error if the facet is not declared in the settings of the helper\n   */\n  toggleFacetRefinement: function toggleFacetRefinement(facet, value) {\n    if (this.isHierarchicalFacet(facet)) {\n      return this.toggleHierarchicalFacetRefinement(facet, value);\n    } else if (this.isConjunctiveFacet(facet)) {\n      return this.toggleConjunctiveFacetRefinement(facet, value);\n    } else if (this.isDisjunctiveFacet(facet)) {\n      return this.toggleDisjunctiveFacetRefinement(facet, value);\n    }\n\n    throw new Error('Cannot refine the undeclared facet ' + facet + '; it should be added to the helper options facets, disjunctiveFacets or hierarchicalFacets');\n  },\n\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters}\n   */\n  toggleConjunctiveFacetRefinement: function toggleConjunctiveFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    return this.setQueryParameters({\n      facetsRefinements: RefinementList.toggleRefinement(this.facetsRefinements, facet, value)\n    });\n  },\n\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters}\n   */\n  toggleExcludeFacetRefinement: function toggleExcludeFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    return this.setQueryParameters({\n      facetsExcludes: RefinementList.toggleRefinement(this.facetsExcludes, facet, value)\n    });\n  },\n\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters}\n   */\n  toggleDisjunctiveFacetRefinement: function toggleDisjunctiveFacetRefinement(facet, value) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');\n    }\n\n    return this.setQueryParameters({\n      disjunctiveFacetsRefinements: RefinementList.toggleRefinement(this.disjunctiveFacetsRefinements, facet, value)\n    });\n  },\n\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters}\n   */\n  toggleHierarchicalFacetRefinement: function toggleHierarchicalFacetRefinement(facet, value) {\n    if (!this.isHierarchicalFacet(facet)) {\n      throw new Error(facet + ' is not defined in the hierarchicalFacets attribute of the helper configuration');\n    }\n\n    var separator = this._getHierarchicalFacetSeparator(this.getHierarchicalFacetByName(facet));\n\n    var mod = {};\n    var upOneOrMultipleLevel = this.hierarchicalFacetsRefinements[facet] !== undefined && this.hierarchicalFacetsRefinements[facet].length > 0 && ( // remove current refinement:\n    // refinement was 'beer > IPA', call is toggleRefine('beer > IPA'), refinement should be `beer`\n    this.hierarchicalFacetsRefinements[facet][0] === value || // remove a parent refinement of the current refinement:\n    //  - refinement was 'beer > IPA > Flying dog'\n    //  - call is toggleRefine('beer > IPA')\n    //  - refinement should be `beer`\n    this.hierarchicalFacetsRefinements[facet][0].indexOf(value + separator) === 0);\n\n    if (upOneOrMultipleLevel) {\n      if (value.indexOf(separator) === -1) {\n        // go back to root level\n        mod[facet] = [];\n      } else {\n        mod[facet] = [value.slice(0, value.lastIndexOf(separator))];\n      }\n    } else {\n      mod[facet] = [value];\n    }\n\n    return this.setQueryParameters({\n      hierarchicalFacetsRefinements: defaults({}, mod, this.hierarchicalFacetsRefinements)\n    });\n  },\n\n  /**\n   * Adds a refinement on a hierarchical facet.\n   * @param {string} facet the facet name\n   * @param {string} path the hierarchical facet path\n   * @return {SearchParameter} the new state\n   * @throws Error if the facet is not defined or if the facet is refined\n   */\n  addHierarchicalFacetRefinement: function (facet, path) {\n    if (this.isHierarchicalFacetRefined(facet)) {\n      throw new Error(facet + ' is already refined.');\n    }\n\n    var mod = {};\n    mod[facet] = [path];\n    return this.setQueryParameters({\n      hierarchicalFacetsRefinements: defaults({}, mod, this.hierarchicalFacetsRefinements)\n    });\n  },\n\n  /**\n   * Removes the refinement set on a hierarchical facet.\n   * @param {string} facet the facet name\n   * @return {SearchParameter} the new state\n   * @throws Error if the facet is not defined or if the facet is not refined\n   */\n  removeHierarchicalFacetRefinement: function (facet) {\n    if (!this.isHierarchicalFacetRefined(facet)) {\n      throw new Error(facet + ' is not refined.');\n    }\n\n    var mod = {};\n    mod[facet] = [];\n    return this.setQueryParameters({\n      hierarchicalFacetsRefinements: defaults({}, mod, this.hierarchicalFacetsRefinements)\n    });\n  },\n\n  /**\n   * Switch the tag refinement\n   * @method\n   * @param {string} tag the tag to remove or add\n   * @return {SearchParameters}\n   */\n  toggleTagRefinement: function toggleTagRefinement(tag) {\n    if (this.isTagRefined(tag)) {\n      return this.removeTagRefinement(tag);\n    }\n\n    return this.addTagRefinement(tag);\n  },\n\n  /**\n   * Test if the facet name is from one of the disjunctive facets\n   * @method\n   * @param {string} facet facet name to test\n   * @return {boolean}\n   */\n  isDisjunctiveFacet: function (facet) {\n    return indexOf(this.disjunctiveFacets, facet) > -1;\n  },\n\n  /**\n   * Test if the facet name is from one of the hierarchical facets\n   * @method\n   * @param {string} facetName facet name to test\n   * @return {boolean}\n   */\n  isHierarchicalFacet: function (facetName) {\n    return this.getHierarchicalFacetByName(facetName) !== undefined;\n  },\n\n  /**\n   * Test if the facet name is from one of the conjunctive/normal facets\n   * @method\n   * @param {string} facet facet name to test\n   * @return {boolean}\n   */\n  isConjunctiveFacet: function (facet) {\n    return indexOf(this.facets, facet) > -1;\n  },\n\n  /**\n   * Returns true if the facet is refined, either for a specific value or in\n   * general.\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} value, optional value. If passed will test that this value\n   * is filtering the given facet.\n   * @return {boolean} returns true if refined\n   */\n  isFacetRefined: function isFacetRefined(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    return RefinementList.isRefined(this.facetsRefinements, facet, value);\n  },\n\n  /**\n   * Returns true if the facet contains exclusions or if a specific value is\n   * excluded.\n   *\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} [value] optional value. If passed will test that this value\n   * is filtering the given facet.\n   * @return {boolean} returns true if refined\n   */\n  isExcludeRefined: function isExcludeRefined(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    return RefinementList.isRefined(this.facetsExcludes, facet, value);\n  },\n\n  /**\n   * Returns true if the facet contains a refinement, or if a value passed is a\n   * refinement for the facet.\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} value optional, will test if the value is used for refinement\n   * if there is one, otherwise will test if the facet contains any refinement\n   * @return {boolean}\n   */\n  isDisjunctiveFacetRefined: function isDisjunctiveFacetRefined(facet, value) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');\n    }\n\n    return RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value);\n  },\n\n  /**\n   * Returns true if the facet contains a refinement, or if a value passed is a\n   * refinement for the facet.\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} value optional, will test if the value is used for refinement\n   * if there is one, otherwise will test if the facet contains any refinement\n   * @return {boolean}\n   */\n  isHierarchicalFacetRefined: function isHierarchicalFacetRefined(facet, value) {\n    if (!this.isHierarchicalFacet(facet)) {\n      throw new Error(facet + ' is not defined in the hierarchicalFacets attribute of the helper configuration');\n    }\n\n    var refinements = this.getHierarchicalRefinement(facet);\n\n    if (!value) {\n      return refinements.length > 0;\n    }\n\n    return indexOf(refinements, value) !== -1;\n  },\n\n  /**\n   * Test if the triple (attribute, operator, value) is already refined.\n   * If only the attribute and the operator are provided, it tests if the\n   * contains any refinement value.\n   * @method\n   * @param {string} attribute attribute for which the refinement is applied\n   * @param {string} [operator] operator of the refinement\n   * @param {string} [value] value of the refinement\n   * @return {boolean} true if it is refined\n   */\n  isNumericRefined: function isNumericRefined(attribute, operator, value) {\n    if (isUndefined(value) && isUndefined(operator)) {\n      return !!this.numericRefinements[attribute];\n    }\n\n    var isOperatorDefined = this.numericRefinements[attribute] && !isUndefined(this.numericRefinements[attribute][operator]);\n\n    if (isUndefined(value) || !isOperatorDefined) {\n      return isOperatorDefined;\n    }\n\n    var parsedValue = valToNumber(value);\n    var isAttributeValueDefined = !isUndefined(findArray(this.numericRefinements[attribute][operator], parsedValue));\n    return isOperatorDefined && isAttributeValueDefined;\n  },\n\n  /**\n   * Returns true if the tag refined, false otherwise\n   * @method\n   * @param {string} tag the tag to check\n   * @return {boolean}\n   */\n  isTagRefined: function isTagRefined(tag) {\n    return indexOf(this.tagRefinements, tag) !== -1;\n  },\n\n  /**\n   * Returns the list of all disjunctive facets refined\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {string[]}\n   */\n  getRefinedDisjunctiveFacets: function getRefinedDisjunctiveFacets() {\n    // attributes used for numeric filter can also be disjunctive\n    var disjunctiveNumericRefinedFacets = intersection(keys(this.numericRefinements), this.disjunctiveFacets);\n    return keys(this.disjunctiveFacetsRefinements).concat(disjunctiveNumericRefinedFacets).concat(this.getRefinedHierarchicalFacets());\n  },\n\n  /**\n   * Returns the list of all disjunctive facets refined\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {string[]}\n   */\n  getRefinedHierarchicalFacets: function getRefinedHierarchicalFacets() {\n    return intersection( // enforce the order between the two arrays,\n    // so that refinement name index === hierarchical facet index\n    map(this.hierarchicalFacets, 'name'), keys(this.hierarchicalFacetsRefinements));\n  },\n\n  /**\n   * Returned the list of all disjunctive facets not refined\n   * @method\n   * @return {string[]}\n   */\n  getUnrefinedDisjunctiveFacets: function () {\n    var refinedFacets = this.getRefinedDisjunctiveFacets();\n    return filter(this.disjunctiveFacets, function (f) {\n      return indexOf(refinedFacets, f) === -1;\n    });\n  },\n  managedParameters: ['index', 'facets', 'disjunctiveFacets', 'facetsRefinements', 'facetsExcludes', 'disjunctiveFacetsRefinements', 'numericRefinements', 'tagRefinements', 'hierarchicalFacets', 'hierarchicalFacetsRefinements'],\n  getQueryParams: function getQueryParams() {\n    var managedParameters = this.managedParameters;\n    var queryParams = {};\n    forOwn(this, function (paramValue, paramName) {\n      if (indexOf(managedParameters, paramName) === -1 && paramValue !== undefined) {\n        queryParams[paramName] = paramValue;\n      }\n    });\n    return queryParams;\n  },\n\n  /**\n   * Let the user retrieve any parameter value from the SearchParameters\n   * @param {string} paramName name of the parameter\n   * @return {any} the value of the parameter\n   */\n  getQueryParameter: function getQueryParameter(paramName) {\n    if (!this.hasOwnProperty(paramName)) {\n      throw new Error(\"Parameter '\" + paramName + \"' is not an attribute of SearchParameters \" + '(http://algolia.github.io/algoliasearch-helper-js/docs/SearchParameters.html)');\n    }\n\n    return this[paramName];\n  },\n\n  /**\n   * Let the user set a specific value for a given parameter. Will return the\n   * same instance if the parameter is invalid or if the value is the same as the\n   * previous one.\n   * @method\n   * @param {string} parameter the parameter name\n   * @param {any} value the value to be set, must be compliant with the definition\n   * of the attribute on the object\n   * @return {SearchParameters} the updated state\n   */\n  setQueryParameter: function setParameter(parameter, value) {\n    if (this[parameter] === value) return this;\n    var modification = {};\n    modification[parameter] = value;\n    return this.setQueryParameters(modification);\n  },\n\n  /**\n   * Let the user set any of the parameters with a plain object.\n   * @method\n   * @param {object} params all the keys and the values to be updated\n   * @return {SearchParameters} a new updated instance\n   */\n  setQueryParameters: function setQueryParameters(params) {\n    if (!params) return this;\n    var error = SearchParameters.validate(this, params);\n\n    if (error) {\n      throw error;\n    }\n\n    var parsedParams = SearchParameters._parseNumbers(params);\n\n    return this.mutateMe(function mergeWith(newInstance) {\n      var ks = keys(params);\n      forEach(ks, function (k) {\n        newInstance[k] = parsedParams[k];\n      });\n      return newInstance;\n    });\n  },\n\n  /**\n   * Returns an object with only the selected attributes.\n   * @param {string[]} filters filters to retrieve only a subset of the state. It\n   * accepts strings that can be either attributes of the SearchParameters (e.g. hitsPerPage)\n   * or attributes of the index with the notation 'attribute:nameOfMyAttribute'\n   * @return {object}\n   */\n  filter: function (filters) {\n    return filterState(this, filters);\n  },\n\n  /**\n   * Helper function to make it easier to build new instances from a mutating\n   * function\n   * @private\n   * @param {function} fn newMutableState -> previousState -> () function that will\n   * change the value of the newMutable to the desired state\n   * @return {SearchParameters} a new instance with the specified modifications applied\n   */\n  mutateMe: function mutateMe(fn) {\n    var newState = new this.constructor(this);\n    fn(newState, this);\n    return newState;\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet separator or the default one (`>`)\n   * @param  {object} hierarchicalFacet\n   * @return {string} returns the hierarchicalFacet.separator or `>` as default\n   */\n  _getHierarchicalFacetSortBy: function (hierarchicalFacet) {\n    return hierarchicalFacet.sortBy || ['isRefined:desc', 'name:asc'];\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet separator or the default one (`>`)\n   * @private\n   * @param  {object} hierarchicalFacet\n   * @return {string} returns the hierarchicalFacet.separator or `>` as default\n   */\n  _getHierarchicalFacetSeparator: function (hierarchicalFacet) {\n    return hierarchicalFacet.separator || ' > ';\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet prefix path or null\n   * @private\n   * @param  {object} hierarchicalFacet\n   * @return {string} returns the hierarchicalFacet.rootPath or null as default\n   */\n  _getHierarchicalRootPath: function (hierarchicalFacet) {\n    return hierarchicalFacet.rootPath || null;\n  },\n\n  /**\n   * Helper function to check if we show the parent level of the hierarchicalFacet\n   * @private\n   * @param  {object} hierarchicalFacet\n   * @return {string} returns the hierarchicalFacet.showParentLevel or true as default\n   */\n  _getHierarchicalShowParentLevel: function (hierarchicalFacet) {\n    if (typeof hierarchicalFacet.showParentLevel === 'boolean') {\n      return hierarchicalFacet.showParentLevel;\n    }\n\n    return true;\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet by it's name\n   * @param  {string} hierarchicalFacetName\n   * @return {object} a hierarchicalFacet\n   */\n  getHierarchicalFacetByName: function (hierarchicalFacetName) {\n    return find(this.hierarchicalFacets, {\n      name: hierarchicalFacetName\n    });\n  },\n\n  /**\n   * Get the current breadcrumb for a hierarchical facet, as an array\n   * @param  {string} facetName Hierarchical facet name\n   * @return {array.<string>} the path as an array of string\n   */\n  getHierarchicalFacetBreadcrumb: function (facetName) {\n    if (!this.isHierarchicalFacet(facetName)) {\n      throw new Error('Cannot get the breadcrumb of an unknown hierarchical facet: `' + facetName + '`');\n    }\n\n    var refinement = this.getHierarchicalRefinement(facetName)[0];\n    if (!refinement) return [];\n\n    var separator = this._getHierarchicalFacetSeparator(this.getHierarchicalFacetByName(facetName));\n\n    var path = refinement.split(separator);\n    return map(path, trim);\n  },\n  toString: function () {\n    return JSON.stringify(this, null, 2);\n  }\n};\n/**\n * Callback used for clearRefinement method\n * @callback SearchParameters.clearCallback\n * @param {OperatorList|FacetList} value the value of the filter\n * @param {string} key the current attribute name\n * @param {string} type `numeric`, `disjunctiveFacet`, `conjunctiveFacet`, `hierarchicalFacet` or `exclude`\n * depending on the type of facet\n * @return {boolean} `true` if the element should be removed. `false` otherwise.\n */\n\nmodule.exports = SearchParameters;","map":{"version":3,"sources":["D:/TT18-EC-Team1-FE/isomorphic/node_modules/algoliasearch-helper/src/SearchParameters/index.js"],"names":["keys","require","intersection","forOwn","forEach","filter","map","reduce","omit","indexOf","isNaN","isEmpty","isEqual","isUndefined","isString","isFunction","find","trim","defaults","merge","valToNumber","filterState","RefinementList","findArray","array","searchedValue","currentValue","SearchParameters","newParameters","params","_parseNumbers","index","query","facets","disjunctiveFacets","hierarchicalFacets","facetsRefinements","facetsExcludes","disjunctiveFacetsRefinements","numericRefinements","tagRefinements","hierarchicalFacetsRefinements","numericFilters","tagFilters","optionalTagFilters","optionalFacetFilters","hitsPerPage","maxValuesPerFacet","page","queryType","typoTolerance","minWordSizefor1Typo","minWordSizefor2Typos","minProximity","allowTyposOnNumericTokens","ignorePlurals","restrictSearchableAttributes","advancedSyntax","analytics","analyticsTags","synonyms","replaceSynonymsInHighlight","optionalWords","removeWordsIfNoResults","attributesToRetrieve","attributesToHighlight","highlightPreTag","highlightPostTag","attributesToSnippet","getRankingInfo","distinct","aroundLatLng","aroundLatLngViaIP","aroundRadius","minimumAroundRadius","aroundPrecision","insideBoundingBox","insidePolygon","snippetEllipsisText","disableExactOnAttributes","enableExactOnSingleWordQuery","offset","length","self","checkForUnknownParameter","paramValue","paramName","PARAMETERS","partialState","numbers","numberKeys","k","value","parsedValue","parseFloat","Array","isArray","geoRect","operators","attribute","values","operator","parsedValues","v","vPrime","make","makeSearchParameters","instance","facet","rootPath","currentRefinement","getHierarchicalRefinement","name","clearRefinements","toggleHierarchicalFacetRefinement","validate","currentState","parameters","Error","prototype","constructor","clear","clearRefinement","patch","_clearNumericRefinements","setQueryParameters","clearTags","undefined","setIndex","setQuery","newQuery","setPage","newPage","setFacets","setDisjunctiveFacets","setHitsPerPage","n","setTypoTolerance","addNumericRefinement","isNumericRefined","mod","slice","push","getConjunctiveRefinements","facetName","isConjunctiveFacet","getDisjunctiveRefinements","isDisjunctiveFacet","getExcludeRefinements","removeNumericRefinement","paramValueAsNumber","key","op","val","getNumericRefinements","getNumericRefinement","hasChanged","newNumericRefinements","memo","operatorList","outValues","predicateResult","addFacet","concat","addDisjunctiveFacet","addHierarchicalFacet","hierarchicalFacet","isHierarchicalFacet","addFacetRefinement","isRefined","addRefinement","addExcludeRefinement","addDisjunctiveFacetRefinement","addTagRefinement","tag","isTagRefined","modification","removeFacet","f","removeDisjunctiveFacet","removeHierarchicalFacet","removeFacetRefinement","removeRefinement","removeExcludeRefinement","removeDisjunctiveFacetRefinement","removeTagRefinement","t","toggleRefinement","toggleFacetRefinement","toggleConjunctiveFacetRefinement","toggleDisjunctiveFacetRefinement","toggleExcludeFacetRefinement","separator","_getHierarchicalFacetSeparator","getHierarchicalFacetByName","upOneOrMultipleLevel","lastIndexOf","addHierarchicalFacetRefinement","path","isHierarchicalFacetRefined","removeHierarchicalFacetRefinement","toggleTagRefinement","isFacetRefined","isExcludeRefined","isDisjunctiveFacetRefined","refinements","isOperatorDefined","isAttributeValueDefined","getRefinedDisjunctiveFacets","disjunctiveNumericRefinedFacets","getRefinedHierarchicalFacets","getUnrefinedDisjunctiveFacets","refinedFacets","managedParameters","getQueryParams","queryParams","getQueryParameter","hasOwnProperty","setQueryParameter","setParameter","parameter","error","parsedParams","mutateMe","mergeWith","newInstance","ks","filters","fn","newState","_getHierarchicalFacetSortBy","sortBy","_getHierarchicalRootPath","_getHierarchicalShowParentLevel","showParentLevel","hierarchicalFacetName","getHierarchicalFacetBreadcrumb","refinement","split","toString","JSON","stringify","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,aAAD,CAAlB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,qBAAD,CAA1B;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,eAAD,CAApB;;AACA,IAAIG,OAAO,GAAGH,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAII,MAAM,GAAGJ,OAAO,CAAC,eAAD,CAApB;;AACA,IAAIK,GAAG,GAAGL,OAAO,CAAC,YAAD,CAAjB;;AACA,IAAIM,MAAM,GAAGN,OAAO,CAAC,eAAD,CAApB;;AACA,IAAIO,IAAI,GAAGP,OAAO,CAAC,aAAD,CAAlB;;AACA,IAAIQ,OAAO,GAAGR,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIS,KAAK,GAAGT,OAAO,CAAC,cAAD,CAAnB;;AACA,IAAIU,OAAO,GAAGV,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIW,OAAO,GAAGX,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIY,WAAW,GAAGZ,OAAO,CAAC,oBAAD,CAAzB;;AACA,IAAIa,QAAQ,GAAGb,OAAO,CAAC,iBAAD,CAAtB;;AACA,IAAIc,UAAU,GAAGd,OAAO,CAAC,mBAAD,CAAxB;;AACA,IAAIe,IAAI,GAAGf,OAAO,CAAC,aAAD,CAAlB;;AACA,IAAIgB,IAAI,GAAGhB,OAAO,CAAC,aAAD,CAAlB;;AAEA,IAAIiB,QAAQ,GAAGjB,OAAO,CAAC,iBAAD,CAAtB;;AACA,IAAIkB,KAAK,GAAGlB,OAAO,CAAC,cAAD,CAAnB;;AAEA,IAAImB,WAAW,GAAGnB,OAAO,CAAC,0BAAD,CAAzB;;AAEA,IAAIoB,WAAW,GAAGpB,OAAO,CAAC,eAAD,CAAzB;;AAEA,IAAIqB,cAAc,GAAGrB,OAAO,CAAC,kBAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASsB,SAAT,CAAmBC,KAAnB,EAA0BC,aAA1B,EAAyC;AACvC,SAAOT,IAAI,CAACQ,KAAD,EAAQ,UAASE,YAAT,EAAuB;AACxC,WAAOd,OAAO,CAACc,YAAD,EAAeD,aAAf,CAAd;AACD,GAFU,CAAX;AAGD;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,gBAAT,CAA0BC,aAA1B,EAAyC;AACvC,MAAIC,MAAM,GAAGD,aAAa,GAAGD,gBAAgB,CAACG,aAAjB,CAA+BF,aAA/B,CAAH,GAAmD,EAA7E;AAEA;AACF;AACA;AACA;;AACE,OAAKG,KAAL,GAAaF,MAAM,CAACE,KAAP,IAAgB,EAA7B,CAPuC,CASvC;;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,KAAL,GAAaH,MAAM,CAACG,KAAP,IAAgB,EAA7B,CAfuC,CAiBvC;;AACA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,MAAL,GAAcJ,MAAM,CAACI,MAAP,IAAiB,EAA/B;AACA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,iBAAL,GAAyBL,MAAM,CAACK,iBAAP,IAA4B,EAArD;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,kBAAL,GAA0BN,MAAM,CAACM,kBAAP,IAA6B,EAAvD,CAxCuC,CA0CvC;;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,iBAAL,GAAyBP,MAAM,CAACO,iBAAP,IAA4B,EAArD;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,cAAL,GAAsBR,MAAM,CAACQ,cAAP,IAAyB,EAA/C;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,4BAAL,GAAoCT,MAAM,CAACS,4BAAP,IAAuC,EAA3E;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,kBAAL,GAA0BV,MAAM,CAACU,kBAAP,IAA6B,EAAvD;AACA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,cAAL,GAAsBX,MAAM,CAACW,cAAP,IAAyB,EAA/C;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,6BAAL,GAAqCZ,MAAM,CAACY,6BAAP,IAAwC,EAA7E;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,cAAL,GAAsBb,MAAM,CAACa,cAA7B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkBd,MAAM,CAACc,UAAzB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,kBAAL,GAA0Bf,MAAM,CAACe,kBAAjC;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,oBAAL,GAA4BhB,MAAM,CAACgB,oBAAnC,CAnJuC,CAsJvC;;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,WAAL,GAAmBjB,MAAM,CAACiB,WAA1B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,iBAAL,GAAyBlB,MAAM,CAACkB,iBAAhC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,IAAL,GAAYnB,MAAM,CAACmB,IAAP,IAAe,CAA3B;AACA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,SAAL,GAAiBpB,MAAM,CAACoB,SAAxB;AACA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,aAAL,GAAqBrB,MAAM,CAACqB,aAA5B;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,mBAAL,GAA2BtB,MAAM,CAACsB,mBAAlC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,oBAAL,GAA4BvB,MAAM,CAACuB,oBAAnC;AACA;AACF;AACA;AACA;;AACE,OAAKC,YAAL,GAAoBxB,MAAM,CAACwB,YAA3B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,yBAAL,GAAiCzB,MAAM,CAACyB,yBAAxC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,aAAL,GAAqB1B,MAAM,CAAC0B,aAA5B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,4BAAL,GAAoC3B,MAAM,CAAC2B,4BAA3C;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,cAAL,GAAsB5B,MAAM,CAAC4B,cAA7B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,SAAL,GAAiB7B,MAAM,CAAC6B,SAAxB;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,aAAL,GAAqB9B,MAAM,CAAC8B,aAA5B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,QAAL,GAAgB/B,MAAM,CAAC+B,QAAvB;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,0BAAL,GAAkChC,MAAM,CAACgC,0BAAzC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,aAAL,GAAqBjC,MAAM,CAACiC,aAA5B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,sBAAL,GAA8BlC,MAAM,CAACkC,sBAArC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,oBAAL,GAA4BnC,MAAM,CAACmC,oBAAnC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,qBAAL,GAA6BpC,MAAM,CAACoC,qBAApC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,eAAL,GAAuBrC,MAAM,CAACqC,eAA9B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,gBAAL,GAAwBtC,MAAM,CAACsC,gBAA/B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,mBAAL,GAA2BvC,MAAM,CAACuC,mBAAlC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,cAAL,GAAsBxC,MAAM,CAACwC,cAA7B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,QAAL,GAAgBzC,MAAM,CAACyC,QAAvB;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,YAAL,GAAoB1C,MAAM,CAAC0C,YAA3B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,iB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","sourcesContent":["'use strict';\n\nvar keys = require('lodash/keys');\nvar intersection = require('lodash/intersection');\nvar forOwn = require('lodash/forOwn');\nvar forEach = require('lodash/forEach');\nvar filter = require('lodash/filter');\nvar map = require('lodash/map');\nvar reduce = require('lodash/reduce');\nvar omit = require('lodash/omit');\nvar indexOf = require('lodash/indexOf');\nvar isNaN = require('lodash/isNaN');\nvar isEmpty = require('lodash/isEmpty');\nvar isEqual = require('lodash/isEqual');\nvar isUndefined = require('lodash/isUndefined');\nvar isString = require('lodash/isString');\nvar isFunction = require('lodash/isFunction');\nvar find = require('lodash/find');\nvar trim = require('lodash/trim');\n\nvar defaults = require('lodash/defaults');\nvar merge = require('lodash/merge');\n\nvar valToNumber = require('../functions/valToNumber');\n\nvar filterState = require('./filterState');\n\nvar RefinementList = require('./RefinementList');\n\n/**\n * like _.find but using _.isEqual to be able to use it\n * to find arrays.\n * @private\n * @param {any[]} array array to search into\n * @param {any} searchedValue the value we're looking for\n * @return {any} the searched value or undefined\n */\nfunction findArray(array, searchedValue) {\n  return find(array, function(currentValue) {\n    return isEqual(currentValue, searchedValue);\n  });\n}\n\n/**\n * The facet list is the structure used to store the list of values used to\n * filter a single attribute.\n * @typedef {string[]} SearchParameters.FacetList\n */\n\n/**\n * Structure to store numeric filters with the operator as the key. The supported operators\n * are `=`, `>`, `<`, `>=`, `<=` and `!=`.\n * @typedef {Object.<string, Array.<number|number[]>>} SearchParameters.OperatorList\n */\n\n/**\n * SearchParameters is the data structure that contains all the information\n * usable for making a search to Algolia API. It doesn't do the search itself,\n * nor does it contains logic about the parameters.\n * It is an immutable object, therefore it has been created in a way that each\n * changes does not change the object itself but returns a copy with the\n * modification.\n * This object should probably not be instantiated outside of the helper. It will\n * be provided when needed. This object is documented for reference as you'll\n * get it from events generated by the {@link AlgoliaSearchHelper}.\n * If need be, instantiate the Helper from the factory function {@link SearchParameters.make}\n * @constructor\n * @classdesc contains all the parameters of a search\n * @param {object|SearchParameters} newParameters existing parameters or partial object\n * for the properties of a new SearchParameters\n * @see SearchParameters.make\n * @example <caption>SearchParameters of the first query in\n *   <a href=\"http://demos.algolia.com/instant-search-demo/\">the instant search demo</a></caption>\n{\n   \"query\": \"\",\n   \"disjunctiveFacets\": [\n      \"customerReviewCount\",\n      \"category\",\n      \"salePrice_range\",\n      \"manufacturer\"\n  ],\n   \"maxValuesPerFacet\": 30,\n   \"page\": 0,\n   \"hitsPerPage\": 10,\n   \"facets\": [\n      \"type\",\n      \"shipping\"\n  ]\n}\n */\nfunction SearchParameters(newParameters) {\n  var params = newParameters ? SearchParameters._parseNumbers(newParameters) : {};\n\n  /**\n   * Targeted index. This parameter is mandatory.\n   * @member {string}\n   */\n  this.index = params.index || '';\n\n  // Query\n  /**\n   * Query string of the instant search. The empty string is a valid query.\n   * @member {string}\n   * @see https://www.algolia.com/doc/rest#param-query\n   */\n  this.query = params.query || '';\n\n  // Facets\n  /**\n   * This attribute contains the list of all the conjunctive facets\n   * used. This list will be added to requested facets in the\n   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.\n   * @member {string[]}\n   */\n  this.facets = params.facets || [];\n  /**\n   * This attribute contains the list of all the disjunctive facets\n   * used. This list will be added to requested facets in the\n   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.\n   * @member {string[]}\n   */\n  this.disjunctiveFacets = params.disjunctiveFacets || [];\n  /**\n   * This attribute contains the list of all the hierarchical facets\n   * used. This list will be added to requested facets in the\n   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.\n   * Hierarchical facets are a sub type of disjunctive facets that\n   * let you filter faceted attributes hierarchically.\n   * @member {string[]|object[]}\n   */\n  this.hierarchicalFacets = params.hierarchicalFacets || [];\n\n  // Refinements\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the conjunctive facets. Each facet must be properly\n   * defined in the `facets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters selected for the associated facet name.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n  this.facetsRefinements = params.facetsRefinements || {};\n  /**\n   * This attribute contains all the filters that need to be\n   * excluded from the conjunctive facets. Each facet must be properly\n   * defined in the `facets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters excluded for the associated facet name.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n  this.facetsExcludes = params.facetsExcludes || {};\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the disjunctive facets. Each facet must be properly\n   * defined in the `disjunctiveFacets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters selected for the associated facet name.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n  this.disjunctiveFacetsRefinements = params.disjunctiveFacetsRefinements || {};\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the numeric attributes.\n   *\n   * The key is the name of the attribute, and the value is the\n   * filters to apply to this attribute.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `numericFilters` attribute.\n   * @member {Object.<string, SearchParameters.OperatorList>}\n   */\n  this.numericRefinements = params.numericRefinements || {};\n  /**\n   * This attribute contains all the tags used to refine the query.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `tagFilters` attribute.\n   * @member {string[]}\n   */\n  this.tagRefinements = params.tagRefinements || [];\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the hierarchical facets. Each facet must be properly\n   * defined in the `hierarchicalFacets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters selected for the associated facet name. The FacetList values\n   * are structured as a string that contain the values for each level\n   * separated by the configured separator.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n  this.hierarchicalFacetsRefinements = params.hierarchicalFacetsRefinements || {};\n\n  /**\n   * Contains the numeric filters in the raw format of the Algolia API. Setting\n   * this parameter is not compatible with the usage of numeric filters methods.\n   * @see https://www.algolia.com/doc/javascript#numericFilters\n   * @member {string}\n   */\n  this.numericFilters = params.numericFilters;\n\n  /**\n   * Contains the tag filters in the raw format of the Algolia API. Setting this\n   * parameter is not compatible with the of the add/remove/toggle methods of the\n   * tag api.\n   * @see https://www.algolia.com/doc/rest#param-tagFilters\n   * @member {string}\n   */\n  this.tagFilters = params.tagFilters;\n\n  /**\n   * Contains the optional tag filters in the raw format of the Algolia API.\n   * @see https://www.algolia.com/doc/rest#param-tagFilters\n   * @member {string}\n   */\n  this.optionalTagFilters = params.optionalTagFilters;\n\n  /**\n   * Contains the optional facet filters in the raw format of the Algolia API.\n   * @see https://www.algolia.com/doc/rest#param-tagFilters\n   * @member {string}\n   */\n  this.optionalFacetFilters = params.optionalFacetFilters;\n\n\n  // Misc. parameters\n  /**\n   * Number of hits to be returned by the search API\n   * @member {number}\n   * @see https://www.algolia.com/doc/rest#param-hitsPerPage\n   */\n  this.hitsPerPage = params.hitsPerPage;\n  /**\n   * Number of values for each faceted attribute\n   * @member {number}\n   * @see https://www.algolia.com/doc/rest#param-maxValuesPerFacet\n   */\n  this.maxValuesPerFacet = params.maxValuesPerFacet;\n  /**\n   * The current page number\n   * @member {number}\n   * @see https://www.algolia.com/doc/rest#param-page\n   */\n  this.page = params.page || 0;\n  /**\n   * How the query should be treated by the search engine.\n   * Possible values: prefixAll, prefixLast, prefixNone\n   * @see https://www.algolia.com/doc/rest#param-queryType\n   * @member {string}\n   */\n  this.queryType = params.queryType;\n  /**\n   * How the typo tolerance behave in the search engine.\n   * Possible values: true, false, min, strict\n   * @see https://www.algolia.com/doc/rest#param-typoTolerance\n   * @member {string}\n   */\n  this.typoTolerance = params.typoTolerance;\n\n  /**\n   * Number of characters to wait before doing one character replacement.\n   * @see https://www.algolia.com/doc/rest#param-minWordSizefor1Typo\n   * @member {number}\n   */\n  this.minWordSizefor1Typo = params.minWordSizefor1Typo;\n  /**\n   * Number of characters to wait before doing a second character replacement.\n   * @see https://www.algolia.com/doc/rest#param-minWordSizefor2Typos\n   * @member {number}\n   */\n  this.minWordSizefor2Typos = params.minWordSizefor2Typos;\n  /**\n   * Configure the precision of the proximity ranking criterion\n   * @see https://www.algolia.com/doc/rest#param-minProximity\n   */\n  this.minProximity = params.minProximity;\n  /**\n   * Should the engine allow typos on numerics.\n   * @see https://www.algolia.com/doc/rest#param-allowTyposOnNumericTokens\n   * @member {boolean}\n   */\n  this.allowTyposOnNumericTokens = params.allowTyposOnNumericTokens;\n  /**\n   * Should the plurals be ignored\n   * @see https://www.algolia.com/doc/rest#param-ignorePlurals\n   * @member {boolean}\n   */\n  this.ignorePlurals = params.ignorePlurals;\n  /**\n   * Restrict which attribute is searched.\n   * @see https://www.algolia.com/doc/rest#param-restrictSearchableAttributes\n   * @member {string}\n   */\n  this.restrictSearchableAttributes = params.restrictSearchableAttributes;\n  /**\n   * Enable the advanced syntax.\n   * @see https://www.algolia.com/doc/rest#param-advancedSyntax\n   * @member {boolean}\n   */\n  this.advancedSyntax = params.advancedSyntax;\n  /**\n   * Enable the analytics\n   * @see https://www.algolia.com/doc/rest#param-analytics\n   * @member {boolean}\n   */\n  this.analytics = params.analytics;\n  /**\n   * Tag of the query in the analytics.\n   * @see https://www.algolia.com/doc/rest#param-analyticsTags\n   * @member {string}\n   */\n  this.analyticsTags = params.analyticsTags;\n  /**\n   * Enable the synonyms\n   * @see https://www.algolia.com/doc/rest#param-synonyms\n   * @member {boolean}\n   */\n  this.synonyms = params.synonyms;\n  /**\n   * Should the engine replace the synonyms in the highlighted results.\n   * @see https://www.algolia.com/doc/rest#param-replaceSynonymsInHighlight\n   * @member {boolean}\n   */\n  this.replaceSynonymsInHighlight = params.replaceSynonymsInHighlight;\n  /**\n   * Add some optional words to those defined in the dashboard\n   * @see https://www.algolia.com/doc/rest#param-optionalWords\n   * @member {string}\n   */\n  this.optionalWords = params.optionalWords;\n  /**\n   * Possible values are \"lastWords\" \"firstWords\" \"allOptional\" \"none\" (default)\n   * @see https://www.algolia.com/doc/rest#param-removeWordsIfNoResults\n   * @member {string}\n   */\n  this.removeWordsIfNoResults = params.removeWordsIfNoResults;\n  /**\n   * List of attributes to retrieve\n   * @see https://www.algolia.com/doc/rest#param-attributesToRetrieve\n   * @member {string}\n   */\n  this.attributesToRetrieve = params.attributesToRetrieve;\n  /**\n   * List of attributes to highlight\n   * @see https://www.algolia.com/doc/rest#param-attributesToHighlight\n   * @member {string}\n   */\n  this.attributesToHighlight = params.attributesToHighlight;\n  /**\n   * Code to be embedded on the left part of the highlighted results\n   * @see https://www.algolia.com/doc/rest#param-highlightPreTag\n   * @member {string}\n   */\n  this.highlightPreTag = params.highlightPreTag;\n  /**\n   * Code to be embedded on the right part of the highlighted results\n   * @see https://www.algolia.com/doc/rest#param-highlightPostTag\n   * @member {string}\n   */\n  this.highlightPostTag = params.highlightPostTag;\n  /**\n   * List of attributes to snippet\n   * @see https://www.algolia.com/doc/rest#param-attributesToSnippet\n   * @member {string}\n   */\n  this.attributesToSnippet = params.attributesToSnippet;\n  /**\n   * Enable the ranking informations in the response, set to 1 to activate\n   * @see https://www.algolia.com/doc/rest#param-getRankingInfo\n   * @member {number}\n   */\n  this.getRankingInfo = params.getRankingInfo;\n  /**\n   * Remove duplicates based on the index setting attributeForDistinct\n   * @see https://www.algolia.com/doc/rest#param-distinct\n   * @member {boolean|number}\n   */\n  this.distinct = params.distinct;\n  /**\n   * Center of the geo search.\n   * @see https://www.algolia.com/doc/rest#param-aroundLatLng\n   * @member {string}\n   */\n  this.aroundLatLng = params.aroundLatLng;\n  /**\n   * Center of the search, retrieve from the user IP.\n   * @see https://www.algolia.com/doc/rest#param-aroundLatLngViaIP\n   * @member {boolean}\n   */\n  this.aroundLatLngViaIP = params.aroundLatLngViaIP;\n  /**\n   * Radius of the geo search.\n   * @see https://www.algolia.com/doc/rest#param-aroundRadius\n   * @member {number}\n   */\n  this.aroundRadius = params.aroundRadius;\n  /**\n   * Precision of the geo search.\n   * @see https://www.algolia.com/doc/rest#param-aroundPrecision\n   * @member {number}\n   */\n  this.minimumAroundRadius = params.minimumAroundRadius;\n  /**\n   * Precision of the geo search.\n   * @see https://www.algolia.com/doc/rest#param-minimumAroundRadius\n   * @member {number}\n   */\n  this.aroundPrecision = params.aroundPrecision;\n  /**\n   * Geo search inside a box.\n   * @see https://www.algolia.com/doc/rest#param-insideBoundingBox\n   * @member {string}\n   */\n  this.insideBoundingBox = params.insideBoundingBox;\n  /**\n   * Geo search inside a polygon.\n   * @see https://www.algolia.com/doc/rest#param-insidePolygon\n   * @member {string}\n   */\n  this.insidePolygon = params.insidePolygon;\n  /**\n   * Allows to specify an ellipsis character for the snippet when we truncate the text\n   * (added before and after if truncated).\n   * The default value is an empty string and we recommend to set it to \"…\"\n   * @see https://www.algolia.com/doc/rest#param-insidePolygon\n   * @member {string}\n   */\n  this.snippetEllipsisText = params.snippetEllipsisText;\n  /**\n   * Allows to specify some attributes name on which exact won't be applied.\n   * Attributes are separated with a comma (for example \"name,address\" ), you can also use a\n   * JSON string array encoding (for example encodeURIComponent('[\"name\",\"address\"]') ).\n   * By default the list is empty.\n   * @see https://www.algolia.com/doc/rest#param-disableExactOnAttributes\n   * @member {string|string[]}\n   */\n  this.disableExactOnAttributes = params.disableExactOnAttributes;\n  /**\n   * Applies 'exact' on single word queries if the word contains at least 3 characters\n   * and is not a stop word.\n   * Can take two values: true or false.\n   * By default, its set to false.\n   * @see https://www.algolia.com/doc/rest#param-enableExactOnSingleWordQuery\n   * @member {boolean}\n   */\n  this.enableExactOnSingleWordQuery = params.enableExactOnSingleWordQuery;\n\n  // Undocumented parameters, still needed otherwise we fail\n  this.offset = params.offset;\n  this.length = params.length;\n\n  var self = this;\n  forOwn(params, function checkForUnknownParameter(paramValue, paramName) {\n    if (SearchParameters.PARAMETERS.indexOf(paramName) === -1) {\n      self[paramName] = paramValue;\n    }\n  });\n}\n\n/**\n * List all the properties in SearchParameters and therefore all the known Algolia properties\n * This doesn't contain any beta/hidden features.\n * @private\n */\nSearchParameters.PARAMETERS = keys(new SearchParameters());\n\n/**\n * @private\n * @param {object} partialState full or part of a state\n * @return {object} a new object with the number keys as number\n */\nSearchParameters._parseNumbers = function(partialState) {\n  // Do not reparse numbers in SearchParameters, they ought to be parsed already\n  if (partialState instanceof SearchParameters) return partialState;\n\n  var numbers = {};\n\n  var numberKeys = [\n    'aroundPrecision',\n    'aroundRadius',\n    'getRankingInfo',\n    'minWordSizefor2Typos',\n    'minWordSizefor1Typo',\n    'page',\n    'maxValuesPerFacet',\n    'distinct',\n    'minimumAroundRadius',\n    'hitsPerPage',\n    'minProximity'\n  ];\n\n  forEach(numberKeys, function(k) {\n    var value = partialState[k];\n    if (isString(value)) {\n      var parsedValue = parseFloat(value);\n      numbers[k] = isNaN(parsedValue) ? value : parsedValue;\n    }\n  });\n\n  // there's two formats of insideBoundingBox, we need to parse\n  // the one which is an array of float geo rectangles\n  if (Array.isArray(partialState.insideBoundingBox)) {\n    numbers.insideBoundingBox = partialState.insideBoundingBox.map(function(geoRect) {\n      return geoRect.map(function(value) {\n        return parseFloat(value);\n      });\n    });\n  }\n\n  if (partialState.numericRefinements) {\n    var numericRefinements = {};\n    forEach(partialState.numericRefinements, function(operators, attribute) {\n      numericRefinements[attribute] = {};\n      forEach(operators, function(values, operator) {\n        var parsedValues = map(values, function(v) {\n          if (Array.isArray(v)) {\n            return map(v, function(vPrime) {\n              if (isString(vPrime)) {\n                return parseFloat(vPrime);\n              }\n              return vPrime;\n            });\n          } else if (isString(v)) {\n            return parseFloat(v);\n          }\n          return v;\n        });\n        numericRefinements[attribute][operator] = parsedValues;\n      });\n    });\n    numbers.numericRefinements = numericRefinements;\n  }\n\n  return merge({}, partialState, numbers);\n};\n\n/**\n * Factory for SearchParameters\n * @param {object|SearchParameters} newParameters existing parameters or partial\n * object for the properties of a new SearchParameters\n * @return {SearchParameters} frozen instance of SearchParameters\n */\nSearchParameters.make = function makeSearchParameters(newParameters) {\n  var instance = new SearchParameters(newParameters);\n\n  forEach(newParameters.hierarchicalFacets, function(facet) {\n    if (facet.rootPath) {\n      var currentRefinement = instance.getHierarchicalRefinement(facet.name);\n\n      if (currentRefinement.length > 0 && currentRefinement[0].indexOf(facet.rootPath) !== 0) {\n        instance = instance.clearRefinements(facet.name);\n      }\n\n      // get it again in case it has been cleared\n      currentRefinement = instance.getHierarchicalRefinement(facet.name);\n      if (currentRefinement.length === 0) {\n        instance = instance.toggleHierarchicalFacetRefinement(facet.name, facet.rootPath);\n      }\n    }\n  });\n\n  return instance;\n};\n\n/**\n * Validates the new parameters based on the previous state\n * @param {SearchParameters} currentState the current state\n * @param {object|SearchParameters} parameters the new parameters to set\n * @return {Error|null} Error if the modification is invalid, null otherwise\n */\nSearchParameters.validate = function(currentState, parameters) {\n  var params = parameters || {};\n\n  if (currentState.tagFilters && params.tagRefinements && params.tagRefinements.length > 0) {\n    return new Error(\n      '[Tags] Cannot switch from the managed tag API to the advanced API. It is probably ' +\n      'an error, if it is really what you want, you should first clear the tags with clearTags method.');\n  }\n\n  if (currentState.tagRefinements.length > 0 && params.tagFilters) {\n    return new Error(\n      '[Tags] Cannot switch from the advanced tag API to the managed API. It is probably ' +\n      'an error, if it is not, you should first clear the tags with clearTags method.');\n  }\n\n  if (currentState.numericFilters && params.numericRefinements && !isEmpty(params.numericRefinements)) {\n    return new Error(\n      \"[Numeric filters] Can't switch from the advanced to the managed API. It\" +\n      ' is probably an error, if this is really what you want, you have to first' +\n      ' clear the numeric filters.');\n  }\n\n  if (!isEmpty(currentState.numericRefinements) && params.numericFilters) {\n    return new Error(\n      \"[Numeric filters] Can't switch from the managed API to the advanced. It\" +\n      ' is probably an error, if this is really what you want, you have to first' +\n      ' clear the numeric filters.');\n  }\n\n  return null;\n};\n\nSearchParameters.prototype = {\n  constructor: SearchParameters,\n\n  /**\n   * Remove all refinements (disjunctive + conjunctive + excludes + numeric filters)\n   * @method\n   * @param {undefined|string|SearchParameters.clearCallback} [attribute] optional string or function\n   * - If not given, means to clear all the filters.\n   * - If `string`, means to clear all refinements for the `attribute` named filter.\n   * - If `function`, means to clear all the refinements that return truthy values.\n   * @return {SearchParameters}\n   */\n  clearRefinements: function clearRefinements(attribute) {\n    var clear = RefinementList.clearRefinement;\n    var patch = {\n      numericRefinements: this._clearNumericRefinements(attribute),\n      facetsRefinements: clear(this.facetsRefinements, attribute, 'conjunctiveFacet'),\n      facetsExcludes: clear(this.facetsExcludes, attribute, 'exclude'),\n      disjunctiveFacetsRefinements: clear(this.disjunctiveFacetsRefinements, attribute, 'disjunctiveFacet'),\n      hierarchicalFacetsRefinements: clear(this.hierarchicalFacetsRefinements, attribute, 'hierarchicalFacet')\n    };\n    if (patch.numericRefinements === this.numericRefinements &&\n        patch.facetsRefinements === this.facetsRefinements &&\n        patch.facetsExcludes === this.facetsExcludes &&\n        patch.disjunctiveFacetsRefinements === this.disjunctiveFacetsRefinements &&\n        patch.hierarchicalFacetsRefinements === this.hierarchicalFacetsRefinements) {\n      return this;\n    }\n    return this.setQueryParameters(patch);\n  },\n  /**\n   * Remove all the refined tags from the SearchParameters\n   * @method\n   * @return {SearchParameters}\n   */\n  clearTags: function clearTags() {\n    if (this.tagFilters === undefined && this.tagRefinements.length === 0) return this;\n\n    return this.setQueryParameters({\n      tagFilters: undefined,\n      tagRefinements: []\n    });\n  },\n  /**\n   * Set the index.\n   * @method\n   * @param {string} index the index name\n   * @return {SearchParameters}\n   */\n  setIndex: function setIndex(index) {\n    if (index === this.index) return this;\n\n    return this.setQueryParameters({\n      index: index\n    });\n  },\n  /**\n   * Query setter\n   * @method\n   * @param {string} newQuery value for the new query\n   * @return {SearchParameters}\n   */\n  setQuery: function setQuery(newQuery) {\n    if (newQuery === this.query) return this;\n\n    return this.setQueryParameters({\n      query: newQuery\n    });\n  },\n  /**\n   * Page setter\n   * @method\n   * @param {number} newPage new page number\n   * @return {SearchParameters}\n   */\n  setPage: function setPage(newPage) {\n    if (newPage === this.page) return this;\n\n    return this.setQueryParameters({\n      page: newPage\n    });\n  },\n  /**\n   * Facets setter\n   * The facets are the simple facets, used for conjunctive (and) faceting.\n   * @method\n   * @param {string[]} facets all the attributes of the algolia records used for conjunctive faceting\n   * @return {SearchParameters}\n   */\n  setFacets: function setFacets(facets) {\n    return this.setQueryParameters({\n      facets: facets\n    });\n  },\n  /**\n   * Disjunctive facets setter\n   * Change the list of disjunctive (or) facets the helper chan handle.\n   * @method\n   * @param {string[]} facets all the attributes of the algolia records used for disjunctive faceting\n   * @return {SearchParameters}\n   */\n  setDisjunctiveFacets: function setDisjunctiveFacets(facets) {\n    return this.setQueryParameters({\n      disjunctiveFacets: facets\n    });\n  },\n  /**\n   * HitsPerPage setter\n   * Hits per page represents the number of hits retrieved for this query\n   * @method\n   * @param {number} n number of hits retrieved per page of results\n   * @return {SearchParameters}\n   */\n  setHitsPerPage: function setHitsPerPage(n) {\n    if (this.hitsPerPage === n) return this;\n\n    return this.setQueryParameters({\n      hitsPerPage: n\n    });\n  },\n  /**\n   * typoTolerance setter\n   * Set the value of typoTolerance\n   * @method\n   * @param {string} typoTolerance new value of typoTolerance (\"true\", \"false\", \"min\" or \"strict\")\n   * @return {SearchParameters}\n   */\n  setTypoTolerance: function setTypoTolerance(typoTolerance) {\n    if (this.typoTolerance === typoTolerance) return this;\n\n    return this.setQueryParameters({\n      typoTolerance: typoTolerance\n    });\n  },\n  /**\n   * Add a numeric filter for a given attribute\n   * When value is an array, they are combined with OR\n   * When value is a single value, it will combined with AND\n   * @method\n   * @param {string} attribute attribute to set the filter on\n   * @param {string} operator operator of the filter (possible values: =, >, >=, <, <=, !=)\n   * @param {number | number[]} value value of the filter\n   * @return {SearchParameters}\n   * @example\n   * // for price = 50 or 40\n   * searchparameter.addNumericRefinement('price', '=', [50, 40]);\n   * @example\n   * // for size = 38 and 40\n   * searchparameter.addNumericRefinement('size', '=', 38);\n   * searchparameter.addNumericRefinement('size', '=', 40);\n   */\n  addNumericRefinement: function(attribute, operator, v) {\n    var value = valToNumber(v);\n\n    if (this.isNumericRefined(attribute, operator, value)) return this;\n\n    var mod = merge({}, this.numericRefinements);\n\n    mod[attribute] = merge({}, mod[attribute]);\n\n    if (mod[attribute][operator]) {\n      // Array copy\n      mod[attribute][operator] = mod[attribute][operator].slice();\n      // Add the element. Concat can't be used here because value can be an array.\n      mod[attribute][operator].push(value);\n    } else {\n      mod[attribute][operator] = [value];\n    }\n\n    return this.setQueryParameters({\n      numericRefinements: mod\n    });\n  },\n  /**\n   * Get the list of conjunctive refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getConjunctiveRefinements: function(facetName) {\n    if (!this.isConjunctiveFacet(facetName)) {\n      throw new Error(facetName + ' is not defined in the facets attribute of the helper configuration');\n    }\n    return this.facetsRefinements[facetName] || [];\n  },\n  /**\n   * Get the list of disjunctive refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getDisjunctiveRefinements: function(facetName) {\n    if (!this.isDisjunctiveFacet(facetName)) {\n      throw new Error(\n        facetName + ' is not defined in the disjunctiveFacets attribute of the helper configuration'\n      );\n    }\n    return this.disjunctiveFacetsRefinements[facetName] || [];\n  },\n  /**\n   * Get the list of hierarchical refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getHierarchicalRefinement: function(facetName) {\n    // we send an array but we currently do not support multiple\n    // hierarchicalRefinements for a hierarchicalFacet\n    return this.hierarchicalFacetsRefinements[facetName] || [];\n  },\n  /**\n   * Get the list of exclude refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getExcludeRefinements: function(facetName) {\n    if (!this.isConjunctiveFacet(facetName)) {\n      throw new Error(facetName + ' is not defined in the facets attribute of the helper configuration');\n    }\n    return this.facetsExcludes[facetName] || [];\n  },\n\n  /**\n   * Remove all the numeric filter for a given (attribute, operator)\n   * @method\n   * @param {string} attribute attribute to set the filter on\n   * @param {string} [operator] operator of the filter (possible values: =, >, >=, <, <=, !=)\n   * @param {number} [number] the value to be removed\n   * @return {SearchParameters}\n   */\n  removeNumericRefinement: function(attribute, operator, paramValue) {\n    if (paramValue !== undefined) {\n      var paramValueAsNumber = valToNumber(paramValue);\n      if (!this.isNumericRefined(attribute, operator, paramValueAsNumber)) return this;\n      return this.setQueryParameters({\n        numericRefinements: this._clearNumericRefinements(function(value, key) {\n          return key === attribute && value.op === operator && isEqual(value.val, paramValueAsNumber);\n        })\n      });\n    } else if (operator !== undefined) {\n      if (!this.isNumericRefined(attribute, operator)) return this;\n      return this.setQueryParameters({\n        numericRefinements: this._clearNumericRefinements(function(value, key) {\n          return key === attribute && value.op === operator;\n        })\n      });\n    }\n\n    if (!this.isNumericRefined(attribute)) return this;\n    return this.setQueryParameters({\n      numericRefinements: this._clearNumericRefinements(function(value, key) {\n        return key === attribute;\n      })\n    });\n  },\n  /**\n   * Get the list of numeric refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {SearchParameters.OperatorList[]} list of refinements\n   */\n  getNumericRefinements: function(facetName) {\n    return this.numericRefinements[facetName] || {};\n  },\n  /**\n   * Return the current refinement for the (attribute, operator)\n   * @param {string} attribute attribute in the record\n   * @param {string} operator operator applied on the refined values\n   * @return {Array.<number|number[]>} refined values\n   */\n  getNumericRefinement: function(attribute, operator) {\n    return this.numericRefinements[attribute] && this.numericRefinements[attribute][operator];\n  },\n  /**\n   * Clear numeric filters.\n   * @method\n   * @private\n   * @param {string|SearchParameters.clearCallback} [attribute] optional string or function\n   * - If not given, means to clear all the filters.\n   * - If `string`, means to clear all refinements for the `attribute` named filter.\n   * - If `function`, means to clear all the refinements that return truthy values.\n   * @return {Object.<string, OperatorList>}\n   */\n  _clearNumericRefinements: function _clearNumericRefinements(attribute) {\n    if (isUndefined(attribute)) {\n      if (isEmpty(this.numericRefinements)) return this.numericRefinements;\n      return {};\n    } else if (isString(attribute)) {\n      if (isEmpty(this.numericRefinements[attribute])) return this.numericRefinements;\n      return omit(this.numericRefinements, attribute);\n    } else if (isFunction(attribute)) {\n      var hasChanged = false;\n      var newNumericRefinements = reduce(this.numericRefinements, function(memo, operators, key) {\n        var operatorList = {};\n\n        forEach(operators, function(values, operator) {\n          var outValues = [];\n          forEach(values, function(value) {\n            var predicateResult = attribute({val: value, op: operator}, key, 'numeric');\n            if (!predicateResult) outValues.push(value);\n          });\n          if (!isEmpty(outValues)) {\n            if (outValues.length !== values.length) hasChanged = true;\n            operatorList[operator] = outValues;\n          }\n          else hasChanged = true;\n        });\n\n        if (!isEmpty(operatorList)) memo[key] = operatorList;\n\n        return memo;\n      }, {});\n\n      if (hasChanged) return newNumericRefinements;\n      return this.numericRefinements;\n    }\n  },\n  /**\n   * Add a facet to the facets attribute of the helper configuration, if it\n   * isn't already present.\n   * @method\n   * @param {string} facet facet name to add\n   * @return {SearchParameters}\n   */\n  addFacet: function addFacet(facet) {\n    if (this.isConjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.setQueryParameters({\n      facets: this.facets.concat([facet])\n    });\n  },\n  /**\n   * Add a disjunctive facet to the disjunctiveFacets attribute of the helper\n   * configuration, if it isn't already present.\n   * @method\n   * @param {string} facet disjunctive facet name to add\n   * @return {SearchParameters}\n   */\n  addDisjunctiveFacet: function addDisjunctiveFacet(facet) {\n    if (this.isDisjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.setQueryParameters({\n      disjunctiveFacets: this.disjunctiveFacets.concat([facet])\n    });\n  },\n  /**\n   * Add a hierarchical facet to the hierarchicalFacets attribute of the helper\n   * configuration.\n   * @method\n   * @param {object} hierarchicalFacet hierarchical facet to add\n   * @return {SearchParameters}\n   * @throws will throw an error if a hierarchical facet with the same name was already declared\n   */\n  addHierarchicalFacet: function addHierarchicalFacet(hierarchicalFacet) {\n    if (this.isHierarchicalFacet(hierarchicalFacet.name)) {\n      throw new Error(\n        'Cannot declare two hierarchical facets with the same name: `' + hierarchicalFacet.name + '`');\n    }\n\n    return this.setQueryParameters({\n      hierarchicalFacets: this.hierarchicalFacets.concat([hierarchicalFacet])\n    });\n  },\n  /**\n   * Add a refinement on a \"normal\" facet\n   * @method\n   * @param {string} facet attribute to apply the faceting on\n   * @param {string} value value of the attribute (will be converted to string)\n   * @return {SearchParameters}\n   */\n  addFacetRefinement: function addFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    if (RefinementList.isRefined(this.facetsRefinements, facet, value)) return this;\n\n    return this.setQueryParameters({\n      facetsRefinements: RefinementList.addRefinement(this.facetsRefinements, facet, value)\n    });\n  },\n  /**\n   * Exclude a value from a \"normal\" facet\n   * @method\n   * @param {string} facet attribute to apply the exclusion on\n   * @param {string} value value of the attribute (will be converted to string)\n   * @return {SearchParameters}\n   */\n  addExcludeRefinement: function addExcludeRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    if (RefinementList.isRefined(this.facetsExcludes, facet, value)) return this;\n\n    return this.setQueryParameters({\n      facetsExcludes: RefinementList.addRefinement(this.facetsExcludes, facet, value)\n    });\n  },\n  /**\n   * Adds a refinement on a disjunctive facet.\n   * @method\n   * @param {string} facet attribute to apply the faceting on\n   * @param {string} value value of the attribute (will be converted to string)\n   * @return {SearchParameters}\n   */\n  addDisjunctiveFacetRefinement: function addDisjunctiveFacetRefinement(facet, value) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(\n        facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');\n    }\n\n    if (RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value)) return this;\n\n    return this.setQueryParameters({\n      disjunctiveFacetsRefinements: RefinementList.addRefinement(\n        this.disjunctiveFacetsRefinements, facet, value)\n    });\n  },\n  /**\n   * addTagRefinement adds a tag to the list used to filter the results\n   * @param {string} tag tag to be added\n   * @return {SearchParameters}\n   */\n  addTagRefinement: function addTagRefinement(tag) {\n    if (this.isTagRefined(tag)) return this;\n\n    var modification = {\n      tagRefinements: this.tagRefinements.concat(tag)\n    };\n\n    return this.setQueryParameters(modification);\n  },\n  /**\n   * Remove a facet from the facets attribute of the helper configuration, if it\n   * is present.\n   * @method\n   * @param {string} facet facet name to remove\n   * @return {SearchParameters}\n   */\n  removeFacet: function removeFacet(facet) {\n    if (!this.isConjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.clearRefinements(facet).setQueryParameters({\n      facets: filter(this.facets, function(f) {\n        return f !== facet;\n      })\n    });\n  },\n  /**\n   * Remove a disjunctive facet from the disjunctiveFacets attribute of the\n   * helper configuration, if it is present.\n   * @method\n   * @param {string} facet disjunctive facet name to remove\n   * @return {SearchParameters}\n   */\n  removeDisjunctiveFacet: function removeDisjunctiveFacet(facet) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.clearRefinements(facet).setQueryParameters({\n      disjunctiveFacets: filter(this.disjunctiveFacets, function(f) {\n        return f !== facet;\n      })\n    });\n  },\n  /**\n   * Remove a hierarchical facet from the hierarchicalFacets attribute of the\n   * helper configuration, if it is present.\n   * @method\n   * @param {string} facet hierarchical facet name to remove\n   * @return {SearchParameters}\n   */\n  removeHierarchicalFacet: function removeHierarchicalFacet(facet) {\n    if (!this.isHierarchicalFacet(facet)) {\n      return this;\n    }\n\n    return this.clearRefinements(facet).setQueryParameters({\n      hierarchicalFacets: filter(this.hierarchicalFacets, function(f) {\n        return f.name !== facet;\n      })\n    });\n  },\n  /**\n   * Remove a refinement set on facet. If a value is provided, it will clear the\n   * refinement for the given value, otherwise it will clear all the refinement\n   * values for the faceted attribute.\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {string} [value] value used to filter\n   * @return {SearchParameters}\n   */\n  removeFacetRefinement: function removeFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    if (!RefinementList.isRefined(this.facetsRefinements, facet, value)) return this;\n\n    return this.setQueryParameters({\n      facetsRefinements: RefinementList.removeRefinement(this.facetsRefinements, facet, value)\n    });\n  },\n  /**\n   * Remove a negative refinement on a facet\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {string} value value used to filter\n   * @return {SearchParameters}\n   */\n  removeExcludeRefinement: function removeExcludeRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    if (!RefinementList.isRefined(this.facetsExcludes, facet, value)) return this;\n\n    return this.setQueryParameters({\n      facetsExcludes: RefinementList.removeRefinement(this.facetsExcludes, facet, value)\n    });\n  },\n  /**\n   * Remove a refinement on a disjunctive facet\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {string} value value used to filter\n   * @return {SearchParameters}\n   */\n  removeDisjunctiveFacetRefinement: function removeDisjunctiveFacetRefinement(facet, value) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(\n        facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');\n    }\n    if (!RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value)) return this;\n\n    return this.setQueryParameters({\n      disjunctiveFacetsRefinements: RefinementList.removeRefinement(\n        this.disjunctiveFacetsRefinements, facet, value)\n    });\n  },\n  /**\n   * Remove a tag from the list of tag refinements\n   * @method\n   * @param {string} tag the tag to remove\n   * @return {SearchParameters}\n   */\n  removeTagRefinement: function removeTagRefinement(tag) {\n    if (!this.isTagRefined(tag)) return this;\n\n    var modification = {\n      tagRefinements: filter(this.tagRefinements, function(t) { return t !== tag; })\n    };\n\n    return this.setQueryParameters(modification);\n  },\n  /**\n   * Generic toggle refinement method to use with facet, disjunctive facets\n   * and hierarchical facets\n   * @param  {string} facet the facet to refine\n   * @param  {string} value the associated value\n   * @return {SearchParameters}\n   * @throws will throw an error if the facet is not declared in the settings of the helper\n   * @deprecated since version 2.19.0, see {@link SearchParameters#toggleFacetRefinement}\n   */\n  toggleRefinement: function toggleRefinement(facet, value) {\n    return this.toggleFacetRefinement(facet, value);\n  },\n  /**\n   * Generic toggle refinement method to use with facet, disjunctive facets\n   * and hierarchical facets\n   * @param  {string} facet the facet to refine\n   * @param  {string} value the associated value\n   * @return {SearchParameters}\n   * @throws will throw an error if the facet is not declared in the settings of the helper\n   */\n  toggleFacetRefinement: function toggleFacetRefinement(facet, value) {\n    if (this.isHierarchicalFacet(facet)) {\n      return this.toggleHierarchicalFacetRefinement(facet, value);\n    } else if (this.isConjunctiveFacet(facet)) {\n      return this.toggleConjunctiveFacetRefinement(facet, value);\n    } else if (this.isDisjunctiveFacet(facet)) {\n      return this.toggleDisjunctiveFacetRefinement(facet, value);\n    }\n\n    throw new Error('Cannot refine the undeclared facet ' + facet +\n      '; it should be added to the helper options facets, disjunctiveFacets or hierarchicalFacets');\n  },\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters}\n   */\n  toggleConjunctiveFacetRefinement: function toggleConjunctiveFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    return this.setQueryParameters({\n      facetsRefinements: RefinementList.toggleRefinement(this.facetsRefinements, facet, value)\n    });\n  },\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters}\n   */\n  toggleExcludeFacetRefinement: function toggleExcludeFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n\n    return this.setQueryParameters({\n      facetsExcludes: RefinementList.toggleRefinement(this.facetsExcludes, facet, value)\n    });\n  },\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters}\n   */\n  toggleDisjunctiveFacetRefinement: function toggleDisjunctiveFacetRefinement(facet, value) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(\n        facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');\n    }\n\n    return this.setQueryParameters({\n      disjunctiveFacetsRefinements: RefinementList.toggleRefinement(\n        this.disjunctiveFacetsRefinements, facet, value)\n    });\n  },\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters}\n   */\n  toggleHierarchicalFacetRefinement: function toggleHierarchicalFacetRefinement(facet, value) {\n    if (!this.isHierarchicalFacet(facet)) {\n      throw new Error(\n        facet + ' is not defined in the hierarchicalFacets attribute of the helper configuration');\n    }\n\n    var separator = this._getHierarchicalFacetSeparator(this.getHierarchicalFacetByName(facet));\n\n    var mod = {};\n\n    var upOneOrMultipleLevel = this.hierarchicalFacetsRefinements[facet] !== undefined &&\n      this.hierarchicalFacetsRefinements[facet].length > 0 && (\n      // remove current refinement:\n      // refinement was 'beer > IPA', call is toggleRefine('beer > IPA'), refinement should be `beer`\n      this.hierarchicalFacetsRefinements[facet][0] === value ||\n      // remove a parent refinement of the current refinement:\n      //  - refinement was 'beer > IPA > Flying dog'\n      //  - call is toggleRefine('beer > IPA')\n      //  - refinement should be `beer`\n      this.hierarchicalFacetsRefinements[facet][0].indexOf(value + separator) === 0\n    );\n\n    if (upOneOrMultipleLevel) {\n      if (value.indexOf(separator) === -1) {\n        // go back to root level\n        mod[facet] = [];\n      } else {\n        mod[facet] = [value.slice(0, value.lastIndexOf(separator))];\n      }\n    } else {\n      mod[facet] = [value];\n    }\n\n    return this.setQueryParameters({\n      hierarchicalFacetsRefinements: defaults({}, mod, this.hierarchicalFacetsRefinements)\n    });\n  },\n\n  /**\n   * Adds a refinement on a hierarchical facet.\n   * @param {string} facet the facet name\n   * @param {string} path the hierarchical facet path\n   * @return {SearchParameter} the new state\n   * @throws Error if the facet is not defined or if the facet is refined\n   */\n  addHierarchicalFacetRefinement: function(facet, path) {\n    if (this.isHierarchicalFacetRefined(facet)) {\n      throw new Error(facet + ' is already refined.');\n    }\n    var mod = {};\n    mod[facet] = [path];\n    return this.setQueryParameters({\n      hierarchicalFacetsRefinements: defaults({}, mod, this.hierarchicalFacetsRefinements)\n    });\n  },\n\n  /**\n   * Removes the refinement set on a hierarchical facet.\n   * @param {string} facet the facet name\n   * @return {SearchParameter} the new state\n   * @throws Error if the facet is not defined or if the facet is not refined\n   */\n  removeHierarchicalFacetRefinement: function(facet) {\n    if (!this.isHierarchicalFacetRefined(facet)) {\n      throw new Error(facet + ' is not refined.');\n    }\n    var mod = {};\n    mod[facet] = [];\n    return this.setQueryParameters({\n      hierarchicalFacetsRefinements: defaults({}, mod, this.hierarchicalFacetsRefinements)\n    });\n  },\n  /**\n   * Switch the tag refinement\n   * @method\n   * @param {string} tag the tag to remove or add\n   * @return {SearchParameters}\n   */\n  toggleTagRefinement: function toggleTagRefinement(tag) {\n    if (this.isTagRefined(tag)) {\n      return this.removeTagRefinement(tag);\n    }\n\n    return this.addTagRefinement(tag);\n  },\n  /**\n   * Test if the facet name is from one of the disjunctive facets\n   * @method\n   * @param {string} facet facet name to test\n   * @return {boolean}\n   */\n  isDisjunctiveFacet: function(facet) {\n    return indexOf(this.disjunctiveFacets, facet) > -1;\n  },\n  /**\n   * Test if the facet name is from one of the hierarchical facets\n   * @method\n   * @param {string} facetName facet name to test\n   * @return {boolean}\n   */\n  isHierarchicalFacet: function(facetName) {\n    return this.getHierarchicalFacetByName(facetName) !== undefined;\n  },\n  /**\n   * Test if the facet name is from one of the conjunctive/normal facets\n   * @method\n   * @param {string} facet facet name to test\n   * @return {boolean}\n   */\n  isConjunctiveFacet: function(facet) {\n    return indexOf(this.facets, facet) > -1;\n  },\n  /**\n   * Returns true if the facet is refined, either for a specific value or in\n   * general.\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} value, optional value. If passed will test that this value\n   * is filtering the given facet.\n   * @return {boolean} returns true if refined\n   */\n  isFacetRefined: function isFacetRefined(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    return RefinementList.isRefined(this.facetsRefinements, facet, value);\n  },\n  /**\n   * Returns true if the facet contains exclusions or if a specific value is\n   * excluded.\n   *\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} [value] optional value. If passed will test that this value\n   * is filtering the given facet.\n   * @return {boolean} returns true if refined\n   */\n  isExcludeRefined: function isExcludeRefined(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(facet + ' is not defined in the facets attribute of the helper configuration');\n    }\n    return RefinementList.isRefined(this.facetsExcludes, facet, value);\n  },\n  /**\n   * Returns true if the facet contains a refinement, or if a value passed is a\n   * refinement for the facet.\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} value optional, will test if the value is used for refinement\n   * if there is one, otherwise will test if the facet contains any refinement\n   * @return {boolean}\n   */\n  isDisjunctiveFacetRefined: function isDisjunctiveFacetRefined(facet, value) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(\n        facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration');\n    }\n    return RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value);\n  },\n  /**\n   * Returns true if the facet contains a refinement, or if a value passed is a\n   * refinement for the facet.\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} value optional, will test if the value is used for refinement\n   * if there is one, otherwise will test if the facet contains any refinement\n   * @return {boolean}\n   */\n  isHierarchicalFacetRefined: function isHierarchicalFacetRefined(facet, value) {\n    if (!this.isHierarchicalFacet(facet)) {\n      throw new Error(\n        facet + ' is not defined in the hierarchicalFacets attribute of the helper configuration');\n    }\n\n    var refinements = this.getHierarchicalRefinement(facet);\n\n    if (!value) {\n      return refinements.length > 0;\n    }\n\n    return indexOf(refinements, value) !== -1;\n  },\n  /**\n   * Test if the triple (attribute, operator, value) is already refined.\n   * If only the attribute and the operator are provided, it tests if the\n   * contains any refinement value.\n   * @method\n   * @param {string} attribute attribute for which the refinement is applied\n   * @param {string} [operator] operator of the refinement\n   * @param {string} [value] value of the refinement\n   * @return {boolean} true if it is refined\n   */\n  isNumericRefined: function isNumericRefined(attribute, operator, value) {\n    if (isUndefined(value) && isUndefined(operator)) {\n      return !!this.numericRefinements[attribute];\n    }\n\n    var isOperatorDefined = this.numericRefinements[attribute] &&\n      !isUndefined(this.numericRefinements[attribute][operator]);\n\n    if (isUndefined(value) || !isOperatorDefined) {\n      return isOperatorDefined;\n    }\n\n    var parsedValue = valToNumber(value);\n    var isAttributeValueDefined = !isUndefined(\n      findArray(this.numericRefinements[attribute][operator], parsedValue)\n    );\n\n    return isOperatorDefined && isAttributeValueDefined;\n  },\n  /**\n   * Returns true if the tag refined, false otherwise\n   * @method\n   * @param {string} tag the tag to check\n   * @return {boolean}\n   */\n  isTagRefined: function isTagRefined(tag) {\n    return indexOf(this.tagRefinements, tag) !== -1;\n  },\n  /**\n   * Returns the list of all disjunctive facets refined\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {string[]}\n   */\n  getRefinedDisjunctiveFacets: function getRefinedDisjunctiveFacets() {\n    // attributes used for numeric filter can also be disjunctive\n    var disjunctiveNumericRefinedFacets = intersection(\n      keys(this.numericRefinements),\n      this.disjunctiveFacets\n    );\n\n    return keys(this.disjunctiveFacetsRefinements)\n      .concat(disjunctiveNumericRefinedFacets)\n      .concat(this.getRefinedHierarchicalFacets());\n  },\n  /**\n   * Returns the list of all disjunctive facets refined\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {string[]}\n   */\n  getRefinedHierarchicalFacets: function getRefinedHierarchicalFacets() {\n    return intersection(\n      // enforce the order between the two arrays,\n      // so that refinement name index === hierarchical facet index\n      map(this.hierarchicalFacets, 'name'),\n      keys(this.hierarchicalFacetsRefinements)\n    );\n  },\n  /**\n   * Returned the list of all disjunctive facets not refined\n   * @method\n   * @return {string[]}\n   */\n  getUnrefinedDisjunctiveFacets: function() {\n    var refinedFacets = this.getRefinedDisjunctiveFacets();\n\n    return filter(this.disjunctiveFacets, function(f) {\n      return indexOf(refinedFacets, f) === -1;\n    });\n  },\n\n  managedParameters: [\n    'index',\n    'facets', 'disjunctiveFacets', 'facetsRefinements',\n    'facetsExcludes', 'disjunctiveFacetsRefinements',\n    'numericRefinements', 'tagRefinements', 'hierarchicalFacets', 'hierarchicalFacetsRefinements'\n  ],\n  getQueryParams: function getQueryParams() {\n    var managedParameters = this.managedParameters;\n\n    var queryParams = {};\n\n    forOwn(this, function(paramValue, paramName) {\n      if (indexOf(managedParameters, paramName) === -1 && paramValue !== undefined) {\n        queryParams[paramName] = paramValue;\n      }\n    });\n\n    return queryParams;\n  },\n  /**\n   * Let the user retrieve any parameter value from the SearchParameters\n   * @param {string} paramName name of the parameter\n   * @return {any} the value of the parameter\n   */\n  getQueryParameter: function getQueryParameter(paramName) {\n    if (!this.hasOwnProperty(paramName)) {\n      throw new Error(\n        \"Parameter '\" + paramName + \"' is not an attribute of SearchParameters \" +\n        '(http://algolia.github.io/algoliasearch-helper-js/docs/SearchParameters.html)');\n    }\n\n    return this[paramName];\n  },\n  /**\n   * Let the user set a specific value for a given parameter. Will return the\n   * same instance if the parameter is invalid or if the value is the same as the\n   * previous one.\n   * @method\n   * @param {string} parameter the parameter name\n   * @param {any} value the value to be set, must be compliant with the definition\n   * of the attribute on the object\n   * @return {SearchParameters} the updated state\n   */\n  setQueryParameter: function setParameter(parameter, value) {\n    if (this[parameter] === value) return this;\n\n    var modification = {};\n\n    modification[parameter] = value;\n\n    return this.setQueryParameters(modification);\n  },\n  /**\n   * Let the user set any of the parameters with a plain object.\n   * @method\n   * @param {object} params all the keys and the values to be updated\n   * @return {SearchParameters} a new updated instance\n   */\n  setQueryParameters: function setQueryParameters(params) {\n    if (!params) return this;\n\n    var error = SearchParameters.validate(this, params);\n\n    if (error) {\n      throw error;\n    }\n\n    var parsedParams = SearchParameters._parseNumbers(params);\n\n    return this.mutateMe(function mergeWith(newInstance) {\n      var ks = keys(params);\n\n      forEach(ks, function(k) {\n        newInstance[k] = parsedParams[k];\n      });\n\n      return newInstance;\n    });\n  },\n\n  /**\n   * Returns an object with only the selected attributes.\n   * @param {string[]} filters filters to retrieve only a subset of the state. It\n   * accepts strings that can be either attributes of the SearchParameters (e.g. hitsPerPage)\n   * or attributes of the index with the notation 'attribute:nameOfMyAttribute'\n   * @return {object}\n   */\n  filter: function(filters) {\n    return filterState(this, filters);\n  },\n  /**\n   * Helper function to make it easier to build new instances from a mutating\n   * function\n   * @private\n   * @param {function} fn newMutableState -> previousState -> () function that will\n   * change the value of the newMutable to the desired state\n   * @return {SearchParameters} a new instance with the specified modifications applied\n   */\n  mutateMe: function mutateMe(fn) {\n    var newState = new this.constructor(this);\n\n    fn(newState, this);\n    return newState;\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet separator or the default one (`>`)\n   * @param  {object} hierarchicalFacet\n   * @return {string} returns the hierarchicalFacet.separator or `>` as default\n   */\n  _getHierarchicalFacetSortBy: function(hierarchicalFacet) {\n    return hierarchicalFacet.sortBy || ['isRefined:desc', 'name:asc'];\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet separator or the default one (`>`)\n   * @private\n   * @param  {object} hierarchicalFacet\n   * @return {string} returns the hierarchicalFacet.separator or `>` as default\n   */\n  _getHierarchicalFacetSeparator: function(hierarchicalFacet) {\n    return hierarchicalFacet.separator || ' > ';\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet prefix path or null\n   * @private\n   * @param  {object} hierarchicalFacet\n   * @return {string} returns the hierarchicalFacet.rootPath or null as default\n   */\n  _getHierarchicalRootPath: function(hierarchicalFacet) {\n    return hierarchicalFacet.rootPath || null;\n  },\n\n  /**\n   * Helper function to check if we show the parent level of the hierarchicalFacet\n   * @private\n   * @param  {object} hierarchicalFacet\n   * @return {string} returns the hierarchicalFacet.showParentLevel or true as default\n   */\n  _getHierarchicalShowParentLevel: function(hierarchicalFacet) {\n    if (typeof hierarchicalFacet.showParentLevel === 'boolean') {\n      return hierarchicalFacet.showParentLevel;\n    }\n    return true;\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet by it's name\n   * @param  {string} hierarchicalFacetName\n   * @return {object} a hierarchicalFacet\n   */\n  getHierarchicalFacetByName: function(hierarchicalFacetName) {\n    return find(\n      this.hierarchicalFacets,\n      {name: hierarchicalFacetName}\n    );\n  },\n\n  /**\n   * Get the current breadcrumb for a hierarchical facet, as an array\n   * @param  {string} facetName Hierarchical facet name\n   * @return {array.<string>} the path as an array of string\n   */\n  getHierarchicalFacetBreadcrumb: function(facetName) {\n    if (!this.isHierarchicalFacet(facetName)) {\n      throw new Error(\n        'Cannot get the breadcrumb of an unknown hierarchical facet: `' + facetName + '`');\n    }\n\n    var refinement = this.getHierarchicalRefinement(facetName)[0];\n    if (!refinement) return [];\n\n    var separator = this._getHierarchicalFacetSeparator(\n      this.getHierarchicalFacetByName(facetName)\n    );\n    var path = refinement.split(separator);\n    return map(path, trim);\n  },\n\n  toString: function() {\n    return JSON.stringify(this, null, 2);\n  }\n};\n\n/**\n * Callback used for clearRefinement method\n * @callback SearchParameters.clearCallback\n * @param {OperatorList|FacetList} value the value of the filter\n * @param {string} key the current attribute name\n * @param {string} type `numeric`, `disjunctiveFacet`, `conjunctiveFacet`, `hierarchicalFacet` or `exclude`\n * depending on the type of facet\n * @return {boolean} `true` if the element should be removed. `false` otherwise.\n */\nmodule.exports = SearchParameters;\n"]},"metadata":{},"sourceType":"script"}