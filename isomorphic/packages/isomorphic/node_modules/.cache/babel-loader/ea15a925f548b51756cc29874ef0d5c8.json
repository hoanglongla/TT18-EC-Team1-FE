{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _indexUtils = require('../core/indexUtils');\n\nvar _createConnector = require('../core/createConnector');\n\nvar _createConnector2 = _interopRequireDefault(_createConnector);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar namespace = 'refinementList';\n\nfunction getId(props) {\n  return props.attributeName;\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  return (0, _indexUtils.getCurrentRefinementValue)(props, searchState, context, namespace + '.' + getId(props), [], function (currentRefinement) {\n    if (typeof currentRefinement === 'string') {\n      // All items were unselected\n      if (currentRefinement === '') {\n        return [];\n      } // Only one item was in the searchState but we know it should be an array\n\n\n      return [currentRefinement];\n    }\n\n    return currentRefinement;\n  });\n}\n\nfunction getValue(name, props, searchState, context) {\n  var currentRefinement = getCurrentRefinement(props, searchState, context);\n  var isAnewValue = currentRefinement.indexOf(name) === -1;\n  var nextRefinement = isAnewValue ? currentRefinement.concat([name]) // cannot use .push(), it mutates\n  : currentRefinement.filter(function (selectedValue) {\n    return selectedValue !== name;\n  }); // cannot use .splice(), it mutates\n\n  return nextRefinement;\n}\n\nfunction getLimit(_ref) {\n  var showMore = _ref.showMore,\n      limitMin = _ref.limitMin,\n      limitMax = _ref.limitMax;\n  return showMore ? limitMax : limitMin;\n}\n\nfunction _refine(props, searchState, nextRefinement, context) {\n  var id = getId(props); // Setting the value to an empty string ensures that it is persisted in\n  // the URL as an empty value.\n  // This is necessary in the case where `defaultRefinement` contains one\n  // item and we try to deselect it. `nextSelected` would be an empty array,\n  // which would not be persisted to the URL.\n  // {foo: ['bar']} => \"foo[0]=bar\"\n  // {foo: []} => \"\"\n\n  var nextValue = _defineProperty({}, id, nextRefinement.length > 0 ? nextRefinement : '');\n\n  var resetPage = true;\n  return (0, _indexUtils.refineValue)(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return (0, _indexUtils.cleanUpValue)(searchState, context, namespace + '.' + getId(props));\n}\n/**\n * connectRefinementList connector provides the logic to build a widget that will\n * give the user the ability to choose multiple values for a specific facet.\n * @name connectRefinementList\n * @kind connector\n * @requirements The attribute passed to the `attributeName` prop must be present in \"attributes for faceting\"\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n * @propType {string} attributeName - the name of the attribute in the record\n * @propType {boolean} [withSearchBox=false] - allow search inside values\n * @propType {string} [operator=or] - How to apply the refinements. Possible values: 'or' or 'and'.\n * @propType {boolean} [showMore=false] - true if the component should display a button that will expand the number of items\n * @propType {number} [limitMin=10] - the minimum number of displayed items\n * @propType {number} [limitMax=20] - the maximun number of displayed items. Only used when showMore is set to `true`\n * @propType {string[]} defaultRefinement - the values of the items selected by default. The searchState of this widget takes the form of a list of `string`s, which correspond to the values of all selected refinements. However, when there are no refinements selected, the value of the searchState is an empty string.\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @providedPropType {function} refine - a function to toggle a refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string[]} currentRefinement - the refinement currently applied\n * @providedPropType {array.<{count: number, isRefined: boolean, label: string, value: string}>} items - the list of items the RefinementList can display.\n * @providedPropType {function} searchForItems - a function to toggle a search inside items values\n * @providedPropType {boolean} isFromSearch - a boolean that says if the `items` props contains facet values from the global search or from the search inside items.\n */\n\n\nvar sortBy = ['isRefined', 'count:desc', 'name:asc'];\nexports.default = (0, _createConnector2.default)({\n  displayName: 'AlgoliaRefinementList',\n  propTypes: {\n    id: _propTypes2.default.string,\n    attributeName: _propTypes2.default.string.isRequired,\n    operator: _propTypes2.default.oneOf(['and', 'or']),\n    showMore: _propTypes2.default.bool,\n    limitMin: _propTypes2.default.number,\n    limitMax: _propTypes2.default.number,\n    defaultRefinement: _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])),\n    withSearchBox: _propTypes2.default.bool,\n    searchForFacetValues: _propTypes2.default.bool,\n    // @deprecated\n    transformItems: _propTypes2.default.func\n  },\n  defaultProps: {\n    operator: 'or',\n    showMore: false,\n    limitMin: 10,\n    limitMax: 20\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults, metadata, searchForFacetValuesResults) {\n    var _this = this;\n\n    var attributeName = props.attributeName;\n    var results = (0, _indexUtils.getResults)(searchResults, this.context);\n    var canRefine = Boolean(results) && Boolean(results.getFacetByName(attributeName));\n    var isFromSearch = Boolean(searchForFacetValuesResults && searchForFacetValuesResults[attributeName] && searchForFacetValuesResults.query !== '');\n    var withSearchBox = props.withSearchBox || props.searchForFacetValues;\n\n    if (process.env.NODE_ENV === 'development' && props.searchForFacetValues) {\n      // eslint-disable-next-line no-console\n      console.warn('react-instantsearch: `searchForFacetValues` has been renamed to' + '`withSearchBox`, this will break in the next major version.');\n    } // Search For Facet Values is not available with derived helper (used for multi index search)\n\n\n    if (props.withSearchBox && this.context.multiIndexContext) {\n      throw new Error('react-instantsearch: searching in *List is not available when used inside a' + ' multi index context');\n    }\n\n    if (!canRefine) {\n      return {\n        items: [],\n        currentRefinement: getCurrentRefinement(props, searchState, this.context),\n        canRefine: canRefine,\n        isFromSearch: isFromSearch,\n        withSearchBox: withSearchBox\n      };\n    }\n\n    var items = isFromSearch ? searchForFacetValuesResults[attributeName].map(function (v) {\n      return {\n        label: v.value,\n        value: getValue(v.value, props, searchState, _this.context),\n        _highlightResult: {\n          label: {\n            value: v.highlighted\n          }\n        },\n        count: v.count,\n        isRefined: v.isRefined\n      };\n    }) : results.getFacetValues(attributeName, {\n      sortBy: sortBy\n    }).map(function (v) {\n      return {\n        label: v.name,\n        value: getValue(v.name, props, searchState, _this.context),\n        count: v.count,\n        isRefined: v.isRefined\n      };\n    });\n    var transformedItems = props.transformItems ? props.transformItems(items) : items;\n    return {\n      items: transformedItems.slice(0, getLimit(props)),\n      currentRefinement: getCurrentRefinement(props, searchState, this.context),\n      isFromSearch: isFromSearch,\n      withSearchBox: withSearchBox,\n      canRefine: items.length > 0\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, this.context);\n  },\n  searchForFacetValues: function searchForFacetValues(props, searchState, nextRefinement) {\n    return {\n      facetName: props.attributeName,\n      query: nextRefinement,\n      maxFacetHits: getLimit(props)\n    };\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, this.context);\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    var attributeName = props.attributeName,\n        operator = props.operator;\n    var addKey = operator === 'and' ? 'addFacet' : 'addDisjunctiveFacet';\n    var addRefinementKey = addKey + 'Refinement';\n    searchParameters = searchParameters.setQueryParameters({\n      maxValuesPerFacet: Math.max(searchParameters.maxValuesPerFacet || 0, getLimit(props))\n    });\n    searchParameters = searchParameters[addKey](attributeName);\n    return getCurrentRefinement(props, searchState, this.context).reduce(function (res, val) {\n      return res[addRefinementKey](attributeName, val);\n    }, searchParameters);\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var id = getId(props);\n    var context = this.context;\n    return {\n      id: id,\n      index: (0, _indexUtils.getIndex)(this.context),\n      items: getCurrentRefinement(props, searchState, context).length > 0 ? [{\n        attributeName: props.attributeName,\n        label: props.attributeName + ': ',\n        currentRefinement: getCurrentRefinement(props, searchState, context),\n        value: function value(nextState) {\n          return _refine(props, nextState, [], context);\n        },\n        items: getCurrentRefinement(props, searchState, context).map(function (item) {\n          return {\n            label: '' + item,\n            value: function value(nextState) {\n              var nextSelectedItems = getCurrentRefinement(props, nextState, context).filter(function (other) {\n                return other !== item;\n              });\n              return _refine(props, searchState, nextSelectedItems, context);\n            }\n          };\n        })\n      }] : []\n    };\n  }\n});","map":{"version":3,"sources":["D:/Team6-FE/isomorphic/node_modules/react-instantsearch/src/connectors/connectRefinementList.js"],"names":["Object","defineProperty","exports","value","_propTypes","require","_propTypes2","_interopRequireDefault","_indexUtils","_createConnector","_createConnector2","obj","__esModule","default","_defineProperty","key","enumerable","configurable","writable","namespace","getId","props","attributeName","getCurrentRefinement","searchState","context","getCurrentRefinementValue","currentRefinement","getValue","name","isAnewValue","indexOf","nextRefinement","concat","filter","selectedValue","getLimit","_ref","showMore","limitMin","limitMax","_refine","id","nextValue","length","resetPage","refineValue","_cleanUp","cleanUpValue","sortBy","displayName","propTypes","string","isRequired","operator","oneOf","bool","number","defaultRefinement","arrayOf","oneOfType","withSearchBox","searchForFacetValues","transformItems","func","defaultProps","getProvidedProps","searchResults","metadata","searchForFacetValuesResults","_this","results","getResults","canRefine","Boolean","getFacetByName","isFromSearch","query","process","env","NODE_ENV","console","warn","multiIndexContext","Error","items","map","v","label","_highlightResult","highlighted","count","isRefined","getFacetValues","transformedItems","slice","refine","facetName","maxFacetHits","cleanUp","getSearchParameters","searchParameters","addKey","addRefinementKey","setQueryParameters","maxValuesPerFacet","Math","max","reduce","res","val","getMetadata","index","getIndex","nextState","item","nextSelectedItems","other"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _indexUtils = require('../core/indexUtils');\n\nvar _createConnector = require('../core/createConnector');\n\nvar _createConnector2 = _interopRequireDefault(_createConnector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar namespace = 'refinementList';\n\nfunction getId(props) {\n  return props.attributeName;\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  return (0, _indexUtils.getCurrentRefinementValue)(props, searchState, context, namespace + '.' + getId(props), [], function (currentRefinement) {\n    if (typeof currentRefinement === 'string') {\n      // All items were unselected\n      if (currentRefinement === '') {\n        return [];\n      }\n\n      // Only one item was in the searchState but we know it should be an array\n      return [currentRefinement];\n    }\n    return currentRefinement;\n  });\n}\n\nfunction getValue(name, props, searchState, context) {\n  var currentRefinement = getCurrentRefinement(props, searchState, context);\n  var isAnewValue = currentRefinement.indexOf(name) === -1;\n  var nextRefinement = isAnewValue ? currentRefinement.concat([name]) // cannot use .push(), it mutates\n  : currentRefinement.filter(function (selectedValue) {\n    return selectedValue !== name;\n  }); // cannot use .splice(), it mutates\n  return nextRefinement;\n}\n\nfunction getLimit(_ref) {\n  var showMore = _ref.showMore,\n      limitMin = _ref.limitMin,\n      limitMax = _ref.limitMax;\n\n  return showMore ? limitMax : limitMin;\n}\n\nfunction _refine(props, searchState, nextRefinement, context) {\n  var id = getId(props);\n  // Setting the value to an empty string ensures that it is persisted in\n  // the URL as an empty value.\n  // This is necessary in the case where `defaultRefinement` contains one\n  // item and we try to deselect it. `nextSelected` would be an empty array,\n  // which would not be persisted to the URL.\n  // {foo: ['bar']} => \"foo[0]=bar\"\n  // {foo: []} => \"\"\n  var nextValue = _defineProperty({}, id, nextRefinement.length > 0 ? nextRefinement : '');\n  var resetPage = true;\n  return (0, _indexUtils.refineValue)(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return (0, _indexUtils.cleanUpValue)(searchState, context, namespace + '.' + getId(props));\n}\n/**\n * connectRefinementList connector provides the logic to build a widget that will\n * give the user the ability to choose multiple values for a specific facet.\n * @name connectRefinementList\n * @kind connector\n * @requirements The attribute passed to the `attributeName` prop must be present in \"attributes for faceting\"\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n * @propType {string} attributeName - the name of the attribute in the record\n * @propType {boolean} [withSearchBox=false] - allow search inside values\n * @propType {string} [operator=or] - How to apply the refinements. Possible values: 'or' or 'and'.\n * @propType {boolean} [showMore=false] - true if the component should display a button that will expand the number of items\n * @propType {number} [limitMin=10] - the minimum number of displayed items\n * @propType {number} [limitMax=20] - the maximun number of displayed items. Only used when showMore is set to `true`\n * @propType {string[]} defaultRefinement - the values of the items selected by default. The searchState of this widget takes the form of a list of `string`s, which correspond to the values of all selected refinements. However, when there are no refinements selected, the value of the searchState is an empty string.\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @providedPropType {function} refine - a function to toggle a refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string[]} currentRefinement - the refinement currently applied\n * @providedPropType {array.<{count: number, isRefined: boolean, label: string, value: string}>} items - the list of items the RefinementList can display.\n * @providedPropType {function} searchForItems - a function to toggle a search inside items values\n * @providedPropType {boolean} isFromSearch - a boolean that says if the `items` props contains facet values from the global search or from the search inside items.\n */\n\nvar sortBy = ['isRefined', 'count:desc', 'name:asc'];\nexports.default = (0, _createConnector2.default)({\n  displayName: 'AlgoliaRefinementList',\n\n  propTypes: {\n    id: _propTypes2.default.string,\n    attributeName: _propTypes2.default.string.isRequired,\n    operator: _propTypes2.default.oneOf(['and', 'or']),\n    showMore: _propTypes2.default.bool,\n    limitMin: _propTypes2.default.number,\n    limitMax: _propTypes2.default.number,\n    defaultRefinement: _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])),\n    withSearchBox: _propTypes2.default.bool,\n    searchForFacetValues: _propTypes2.default.bool, // @deprecated\n    transformItems: _propTypes2.default.func\n  },\n\n  defaultProps: {\n    operator: 'or',\n    showMore: false,\n    limitMin: 10,\n    limitMax: 20\n  },\n\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults, metadata, searchForFacetValuesResults) {\n    var _this = this;\n\n    var attributeName = props.attributeName;\n\n    var results = (0, _indexUtils.getResults)(searchResults, this.context);\n\n    var canRefine = Boolean(results) && Boolean(results.getFacetByName(attributeName));\n\n    var isFromSearch = Boolean(searchForFacetValuesResults && searchForFacetValuesResults[attributeName] && searchForFacetValuesResults.query !== '');\n    var withSearchBox = props.withSearchBox || props.searchForFacetValues;\n    if (process.env.NODE_ENV === 'development' && props.searchForFacetValues) {\n      // eslint-disable-next-line no-console\n      console.warn('react-instantsearch: `searchForFacetValues` has been renamed to' + '`withSearchBox`, this will break in the next major version.');\n    }\n    // Search For Facet Values is not available with derived helper (used for multi index search)\n    if (props.withSearchBox && this.context.multiIndexContext) {\n      throw new Error('react-instantsearch: searching in *List is not available when used inside a' + ' multi index context');\n    }\n\n    if (!canRefine) {\n      return {\n        items: [],\n        currentRefinement: getCurrentRefinement(props, searchState, this.context),\n        canRefine: canRefine,\n        isFromSearch: isFromSearch,\n        withSearchBox: withSearchBox\n      };\n    }\n\n    var items = isFromSearch ? searchForFacetValuesResults[attributeName].map(function (v) {\n      return {\n        label: v.value,\n        value: getValue(v.value, props, searchState, _this.context),\n        _highlightResult: { label: { value: v.highlighted } },\n        count: v.count,\n        isRefined: v.isRefined\n      };\n    }) : results.getFacetValues(attributeName, { sortBy: sortBy }).map(function (v) {\n      return {\n        label: v.name,\n        value: getValue(v.name, props, searchState, _this.context),\n        count: v.count,\n        isRefined: v.isRefined\n      };\n    });\n\n    var transformedItems = props.transformItems ? props.transformItems(items) : items;\n\n    return {\n      items: transformedItems.slice(0, getLimit(props)),\n      currentRefinement: getCurrentRefinement(props, searchState, this.context),\n      isFromSearch: isFromSearch,\n      withSearchBox: withSearchBox,\n      canRefine: items.length > 0\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, this.context);\n  },\n  searchForFacetValues: function searchForFacetValues(props, searchState, nextRefinement) {\n    return {\n      facetName: props.attributeName,\n      query: nextRefinement,\n      maxFacetHits: getLimit(props)\n    };\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, this.context);\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    var attributeName = props.attributeName,\n        operator = props.operator;\n\n\n    var addKey = operator === 'and' ? 'addFacet' : 'addDisjunctiveFacet';\n    var addRefinementKey = addKey + 'Refinement';\n\n    searchParameters = searchParameters.setQueryParameters({\n      maxValuesPerFacet: Math.max(searchParameters.maxValuesPerFacet || 0, getLimit(props))\n    });\n\n    searchParameters = searchParameters[addKey](attributeName);\n\n    return getCurrentRefinement(props, searchState, this.context).reduce(function (res, val) {\n      return res[addRefinementKey](attributeName, val);\n    }, searchParameters);\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var id = getId(props);\n    var context = this.context;\n    return {\n      id: id,\n      index: (0, _indexUtils.getIndex)(this.context),\n      items: getCurrentRefinement(props, searchState, context).length > 0 ? [{\n        attributeName: props.attributeName,\n        label: props.attributeName + ': ',\n        currentRefinement: getCurrentRefinement(props, searchState, context),\n        value: function value(nextState) {\n          return _refine(props, nextState, [], context);\n        },\n        items: getCurrentRefinement(props, searchState, context).map(function (item) {\n          return {\n            label: '' + item,\n            value: function value(nextState) {\n              var nextSelectedItems = getCurrentRefinement(props, nextState, context).filter(function (other) {\n                return other !== item;\n              });\n              return _refine(props, searchState, nextSelectedItems, context);\n            }\n          };\n        })\n      }] : []\n    };\n  }\n});"]},"metadata":{},"sourceType":"script"}