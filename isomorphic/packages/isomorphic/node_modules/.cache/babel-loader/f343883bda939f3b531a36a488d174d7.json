{"ast":null,"code":"'use strict';\n/**\n * Functions to manipulate refinement lists\n *\n * The RefinementList is not formally defined through a prototype but is based\n * on a specific structure.\n *\n * @module SearchParameters.refinementList\n *\n * @typedef {string[]} SearchParameters.refinementList.Refinements\n * @typedef {Object.<string, SearchParameters.refinementList.Refinements>} SearchParameters.refinementList.RefinementList\n */\n\nvar isUndefined = require('lodash/isUndefined');\n\nvar isString = require('lodash/isString');\n\nvar isFunction = require('lodash/isFunction');\n\nvar isEmpty = require('lodash/isEmpty');\n\nvar defaults = require('lodash/defaults');\n\nvar reduce = require('lodash/reduce');\n\nvar filter = require('lodash/filter');\n\nvar omit = require('lodash/omit');\n\nvar lib = {\n  /**\n   * Adds a refinement to a RefinementList\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement, if the value is not a string it will be converted\n   * @return {RefinementList} a new and updated refinement list\n   */\n  addRefinement: function addRefinement(refinementList, attribute, value) {\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return refinementList;\n    }\n\n    var valueAsString = '' + value;\n    var facetRefinement = !refinementList[attribute] ? [valueAsString] : refinementList[attribute].concat(valueAsString);\n    var mod = {};\n    mod[attribute] = facetRefinement;\n    return defaults({}, mod, refinementList);\n  },\n\n  /**\n   * Removes refinement(s) for an attribute:\n   *  - if the value is specified removes the refinement for the value on the attribute\n   *  - if no value is specified removes all the refinements for this attribute\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} [value] the value of the refinement\n   * @return {RefinementList} a new and updated refinement lst\n   */\n  removeRefinement: function removeRefinement(refinementList, attribute, value) {\n    if (isUndefined(value)) {\n      return lib.clearRefinement(refinementList, attribute);\n    }\n\n    var valueAsString = '' + value;\n    return lib.clearRefinement(refinementList, function (v, f) {\n      return attribute === f && valueAsString === v;\n    });\n  },\n\n  /**\n   * Toggles the refinement value for an attribute.\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement\n   * @return {RefinementList} a new and updated list\n   */\n  toggleRefinement: function toggleRefinement(refinementList, attribute, value) {\n    if (isUndefined(value)) throw new Error('toggleRefinement should be used with a value');\n\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return lib.removeRefinement(refinementList, attribute, value);\n    }\n\n    return lib.addRefinement(refinementList, attribute, value);\n  },\n\n  /**\n   * Clear all or parts of a RefinementList. Depending on the arguments, three\n   * kinds of behavior can happen:\n   *  - if no attribute is provided: clears the whole list\n   *  - if an attribute is provided as a string: clears the list for the specific attribute\n   *  - if an attribute is provided as a function: discards the elements for which the function returns true\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} [attribute] the attribute or function to discard\n   * @param {string} [refinementType] optional parameter to give more context to the attribute function\n   * @return {RefinementList} a new and updated refinement list\n   */\n  clearRefinement: function clearRefinement(refinementList, attribute, refinementType) {\n    if (isUndefined(attribute)) {\n      if (isEmpty(refinementList)) return refinementList;\n      return {};\n    } else if (isString(attribute)) {\n      if (isEmpty(refinementList[attribute])) return refinementList;\n      return omit(refinementList, attribute);\n    } else if (isFunction(attribute)) {\n      var hasChanged = false;\n      var newRefinementList = reduce(refinementList, function (memo, values, key) {\n        var facetList = filter(values, function (value) {\n          return !attribute(value, key, refinementType);\n        });\n\n        if (!isEmpty(facetList)) {\n          if (facetList.length !== values.length) hasChanged = true;\n          memo[key] = facetList;\n        } else hasChanged = true;\n\n        return memo;\n      }, {});\n      if (hasChanged) return newRefinementList;\n      return refinementList;\n    }\n  },\n\n  /**\n   * Test if the refinement value is used for the attribute. If no refinement value\n   * is provided, test if the refinementList contains any refinement for the\n   * given attribute.\n   * @param {RefinementList} refinementList the list of refinement\n   * @param {string} attribute name of the attribute\n   * @param {string} [refinementValue] value of the filter/refinement\n   * @return {boolean}\n   */\n  isRefined: function isRefined(refinementList, attribute, refinementValue) {\n    var indexOf = require('lodash/indexOf');\n\n    var containsRefinements = !!refinementList[attribute] && refinementList[attribute].length > 0;\n\n    if (isUndefined(refinementValue) || !containsRefinements) {\n      return containsRefinements;\n    }\n\n    var refinementValueAsString = '' + refinementValue;\n    return indexOf(refinementList[attribute], refinementValueAsString) !== -1;\n  }\n};\nmodule.exports = lib;","map":{"version":3,"sources":["D:/Team6-FE/isomorphic/node_modules/algoliasearch-helper/src/SearchParameters/RefinementList.js"],"names":["isUndefined","require","isString","isFunction","isEmpty","defaults","reduce","filter","omit","lib","addRefinement","refinementList","attribute","value","isRefined","valueAsString","facetRefinement","concat","mod","removeRefinement","clearRefinement","v","f","toggleRefinement","Error","refinementType","hasChanged","newRefinementList","memo","values","key","facetList","length","refinementValue","indexOf","containsRefinements","refinementValueAsString","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Functions to manipulate refinement lists\n *\n * The RefinementList is not formally defined through a prototype but is based\n * on a specific structure.\n *\n * @module SearchParameters.refinementList\n *\n * @typedef {string[]} SearchParameters.refinementList.Refinements\n * @typedef {Object.<string, SearchParameters.refinementList.Refinements>} SearchParameters.refinementList.RefinementList\n */\n\nvar isUndefined = require('lodash/isUndefined');\nvar isString = require('lodash/isString');\nvar isFunction = require('lodash/isFunction');\nvar isEmpty = require('lodash/isEmpty');\nvar defaults = require('lodash/defaults');\n\nvar reduce = require('lodash/reduce');\nvar filter = require('lodash/filter');\nvar omit = require('lodash/omit');\n\nvar lib = {\n  /**\n   * Adds a refinement to a RefinementList\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement, if the value is not a string it will be converted\n   * @return {RefinementList} a new and updated refinement list\n   */\n  addRefinement: function addRefinement(refinementList, attribute, value) {\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return refinementList;\n    }\n\n    var valueAsString = '' + value;\n\n    var facetRefinement = !refinementList[attribute] ?\n      [valueAsString] :\n      refinementList[attribute].concat(valueAsString);\n\n    var mod = {};\n\n    mod[attribute] = facetRefinement;\n\n    return defaults({}, mod, refinementList);\n  },\n  /**\n   * Removes refinement(s) for an attribute:\n   *  - if the value is specified removes the refinement for the value on the attribute\n   *  - if no value is specified removes all the refinements for this attribute\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} [value] the value of the refinement\n   * @return {RefinementList} a new and updated refinement lst\n   */\n  removeRefinement: function removeRefinement(refinementList, attribute, value) {\n    if (isUndefined(value)) {\n      return lib.clearRefinement(refinementList, attribute);\n    }\n\n    var valueAsString = '' + value;\n\n    return lib.clearRefinement(refinementList, function(v, f) {\n      return attribute === f && valueAsString === v;\n    });\n  },\n  /**\n   * Toggles the refinement value for an attribute.\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement\n   * @return {RefinementList} a new and updated list\n   */\n  toggleRefinement: function toggleRefinement(refinementList, attribute, value) {\n    if (isUndefined(value)) throw new Error('toggleRefinement should be used with a value');\n\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return lib.removeRefinement(refinementList, attribute, value);\n    }\n\n    return lib.addRefinement(refinementList, attribute, value);\n  },\n  /**\n   * Clear all or parts of a RefinementList. Depending on the arguments, three\n   * kinds of behavior can happen:\n   *  - if no attribute is provided: clears the whole list\n   *  - if an attribute is provided as a string: clears the list for the specific attribute\n   *  - if an attribute is provided as a function: discards the elements for which the function returns true\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} [attribute] the attribute or function to discard\n   * @param {string} [refinementType] optional parameter to give more context to the attribute function\n   * @return {RefinementList} a new and updated refinement list\n   */\n  clearRefinement: function clearRefinement(refinementList, attribute, refinementType) {\n    if (isUndefined(attribute)) {\n      if (isEmpty(refinementList)) return refinementList;\n      return {};\n    } else if (isString(attribute)) {\n      if (isEmpty(refinementList[attribute])) return refinementList;\n      return omit(refinementList, attribute);\n    } else if (isFunction(attribute)) {\n      var hasChanged = false;\n\n      var newRefinementList = reduce(refinementList, function(memo, values, key) {\n        var facetList = filter(values, function(value) {\n          return !attribute(value, key, refinementType);\n        });\n\n        if (!isEmpty(facetList)) {\n          if (facetList.length !== values.length) hasChanged = true;\n          memo[key] = facetList;\n        }\n        else hasChanged = true;\n\n        return memo;\n      }, {});\n\n      if (hasChanged) return newRefinementList;\n      return refinementList;\n    }\n  },\n  /**\n   * Test if the refinement value is used for the attribute. If no refinement value\n   * is provided, test if the refinementList contains any refinement for the\n   * given attribute.\n   * @param {RefinementList} refinementList the list of refinement\n   * @param {string} attribute name of the attribute\n   * @param {string} [refinementValue] value of the filter/refinement\n   * @return {boolean}\n   */\n  isRefined: function isRefined(refinementList, attribute, refinementValue) {\n    var indexOf = require('lodash/indexOf');\n\n    var containsRefinements = !!refinementList[attribute] &&\n      refinementList[attribute].length > 0;\n\n    if (isUndefined(refinementValue) || !containsRefinements) {\n      return containsRefinements;\n    }\n\n    var refinementValueAsString = '' + refinementValue;\n\n    return indexOf(refinementList[attribute], refinementValueAsString) !== -1;\n  }\n};\n\nmodule.exports = lib;\n"]},"metadata":{},"sourceType":"script"}