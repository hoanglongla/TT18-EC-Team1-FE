{"ast":null,"code":"'use strict';\n\nvar forEach = require('lodash/forEach');\n\nvar compact = require('lodash/compact');\n\nvar indexOf = require('lodash/indexOf');\n\nvar findIndex = require('lodash/findIndex');\n\nvar get = require('lodash/get');\n\nvar sumBy = require('lodash/sumBy');\n\nvar find = require('lodash/find');\n\nvar includes = require('lodash/includes');\n\nvar map = require('lodash/map');\n\nvar orderBy = require('lodash/orderBy');\n\nvar defaults = require('lodash/defaults');\n\nvar merge = require('lodash/merge');\n\nvar isFunction = require('lodash/isFunction');\n\nvar partial = require('lodash/partial');\n\nvar partialRight = require('lodash/partialRight');\n\nvar formatSort = require('../functions/formatSort');\n\nvar generateHierarchicalTree = require('./generate-hierarchical-tree');\n/**\n * @typedef SearchResults.Facet\n * @type {object}\n * @property {string} name name of the attribute in the record\n * @property {object} data the faceting data: value, number of entries\n * @property {object} stats undefined unless facet_stats is retrieved from algolia\n */\n\n/**\n * @typedef SearchResults.HierarchicalFacet\n * @type {object}\n * @property {string} name name of the current value given the hierarchical level, trimmed.\n * If root node, you get the facet name\n * @property {number} count number of objects matching this hierarchical value\n * @property {string} path the current hierarchical value full path\n * @property {boolean} isRefined `true` if the current value was refined, `false` otherwise\n * @property {HierarchicalFacet[]} data sub values for the current level\n */\n\n/**\n * @typedef SearchResults.FacetValue\n * @type {object}\n * @property {string} name the facet value itself\n * @property {number} count times this facet appears in the results\n * @property {boolean} isRefined is the facet currently selected\n * @property {boolean} isExcluded is the facet currently excluded (only for conjunctive facets)\n */\n\n/**\n * @typedef Refinement\n * @type {object}\n * @property {string} type the type of filter used:\n * `numeric`, `facet`, `exclude`, `disjunctive`, `hierarchical`\n * @property {string} attributeName name of the attribute used for filtering\n * @property {string} name the value of the filter\n * @property {number} numericValue the value as a number. Only for numeric filters.\n * @property {string} operator the operator used. Only for numeric filters.\n * @property {number} count the number of computed hits for this filter. Only on facets.\n * @property {boolean} exhaustive if the count is exhaustive\n */\n\n\nfunction getIndices(obj) {\n  var indices = {};\n  forEach(obj, function (val, idx) {\n    indices[val] = idx;\n  });\n  return indices;\n}\n\nfunction assignFacetStats(dest, facetStats, key) {\n  if (facetStats && facetStats[key]) {\n    dest.stats = facetStats[key];\n  }\n}\n\nfunction findMatchingHierarchicalFacetFromAttributeName(hierarchicalFacets, hierarchicalAttributeName) {\n  return find(hierarchicalFacets, function facetKeyMatchesAttribute(hierarchicalFacet) {\n    return includes(hierarchicalFacet.attributes, hierarchicalAttributeName);\n  });\n}\n/*eslint-disable */\n\n/**\n * Constructor for SearchResults\n * @class\n * @classdesc SearchResults contains the results of a query to Algolia using the\n * {@link AlgoliaSearchHelper}.\n * @param {SearchParameters} state state that led to the response\n * @param {array.<object>} results the results from algolia client\n * @example <caption>SearchResults of the first query in\n * <a href=\"http://demos.algolia.com/instant-search-demo\">the instant search demo</a></caption>\n{\n   \"hitsPerPage\": 10,\n   \"processingTimeMS\": 2,\n   \"facets\": [\n      {\n         \"name\": \"type\",\n         \"data\": {\n            \"HardGood\": 6627,\n            \"BlackTie\": 550,\n            \"Music\": 665,\n            \"Software\": 131,\n            \"Game\": 456,\n            \"Movie\": 1571\n         },\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"Free shipping\": 5507\n         },\n         \"name\": \"shipping\"\n      }\n  ],\n   \"hits\": [\n      {\n         \"thumbnailImage\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_54x108_s.gif\",\n         \"_highlightResult\": {\n            \"shortDescription\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n               \"matchedWords\": []\n            },\n            \"category\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Computer Security Software\",\n               \"matchedWords\": []\n            },\n            \"manufacturer\": {\n               \"matchedWords\": [],\n               \"value\": \"Webroot\",\n               \"matchLevel\": \"none\"\n            },\n            \"name\": {\n               \"value\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n               \"matchedWords\": [],\n               \"matchLevel\": \"none\"\n            }\n         },\n         \"image\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_105x210_sc.jpg\",\n         \"shipping\": \"Free shipping\",\n         \"bestSellingRank\": 4,\n         \"shortDescription\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n         \"url\": \"http://www.bestbuy.com/site/webroot-secureanywhere-internet-security-3-devi…d=1219060687969&skuId=1688832&cmp=RMX&ky=2d3GfEmNIzjA0vkzveHdZEBgpPCyMnLTJ\",\n         \"name\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n         \"category\": \"Computer Security Software\",\n         \"salePrice_range\": \"1 - 50\",\n         \"objectID\": \"1688832\",\n         \"type\": \"Software\",\n         \"customerReviewCount\": 5980,\n         \"salePrice\": 49.99,\n         \"manufacturer\": \"Webroot\"\n      },\n      ....\n  ],\n   \"nbHits\": 10000,\n   \"disjunctiveFacets\": [\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"5\": 183,\n            \"12\": 112,\n            \"7\": 149,\n            ...\n         },\n         \"name\": \"customerReviewCount\",\n         \"stats\": {\n            \"max\": 7461,\n            \"avg\": 157.939,\n            \"min\": 1\n         }\n      },\n      {\n         \"data\": {\n            \"Printer Ink\": 142,\n            \"Wireless Speakers\": 60,\n            \"Point & Shoot Cameras\": 48,\n            ...\n         },\n         \"name\": \"category\",\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"> 5000\": 2,\n            \"1 - 50\": 6524,\n            \"501 - 2000\": 566,\n            \"201 - 500\": 1501,\n            \"101 - 200\": 1360,\n            \"2001 - 5000\": 47\n         },\n         \"name\": \"salePrice_range\"\n      },\n      {\n         \"data\": {\n            \"Dynex™\": 202,\n            \"Insignia™\": 230,\n            \"PNY\": 72,\n            ...\n         },\n         \"name\": \"manufacturer\",\n         \"exhaustive\": false\n      }\n  ],\n   \"query\": \"\",\n   \"nbPages\": 100,\n   \"page\": 0,\n   \"index\": \"bestbuy\"\n}\n **/\n\n/*eslint-enable */\n\n\nfunction SearchResults(state, results) {\n  var mainSubResponse = results[0];\n  this._rawResults = results;\n  /**\n   * query used to generate the results\n   * @member {string}\n   */\n\n  this.query = mainSubResponse.query;\n  /**\n   * The query as parsed by the engine given all the rules.\n   * @member {string}\n   */\n\n  this.parsedQuery = mainSubResponse.parsedQuery;\n  /**\n   * all the records that match the search parameters. Each record is\n   * augmented with a new attribute `_highlightResult`\n   * which is an object keyed by attribute and with the following properties:\n   *  - `value` : the value of the facet highlighted (html)\n   *  - `matchLevel`: full, partial or none depending on how the query terms match\n   * @member {object[]}\n   */\n\n  this.hits = mainSubResponse.hits;\n  /**\n   * index where the results come from\n   * @member {string}\n   */\n\n  this.index = mainSubResponse.index;\n  /**\n   * number of hits per page requested\n   * @member {number}\n   */\n\n  this.hitsPerPage = mainSubResponse.hitsPerPage;\n  /**\n   * total number of hits of this query on the index\n   * @member {number}\n   */\n\n  this.nbHits = mainSubResponse.nbHits;\n  /**\n   * total number of pages with respect to the number of hits per page and the total number of hits\n   * @member {number}\n   */\n\n  this.nbPages = mainSubResponse.nbPages;\n  /**\n   * current page\n   * @member {number}\n   */\n\n  this.page = mainSubResponse.page;\n  /**\n   * sum of the processing time of all the queries\n   * @member {number}\n   */\n\n  this.processingTimeMS = sumBy(results, 'processingTimeMS');\n  /**\n   * The position if the position was guessed by IP.\n   * @member {string}\n   * @example \"48.8637,2.3615\",\n   */\n\n  this.aroundLatLng = mainSubResponse.aroundLatLng;\n  /**\n   * The radius computed by Algolia.\n   * @member {string}\n   * @example \"126792922\",\n   */\n\n  this.automaticRadius = mainSubResponse.automaticRadius;\n  /**\n   * String identifying the server used to serve this request.\n   * @member {string}\n   * @example \"c7-use-2.algolia.net\",\n   */\n\n  this.serverUsed = mainSubResponse.serverUsed;\n  /**\n   * Boolean that indicates if the computation of the counts did time out.\n   * @deprecated\n   * @member {boolean}\n   */\n\n  this.timeoutCounts = mainSubResponse.timeoutCounts;\n  /**\n   * Boolean that indicates if the computation of the hits did time out.\n   * @deprecated\n   * @member {boolean}\n   */\n\n  this.timeoutHits = mainSubResponse.timeoutHits;\n  /**\n   * True if the counts of the facets is exhaustive\n   * @member {boolean}\n   */\n\n  this.exhaustiveFacetsCount = mainSubResponse.exhaustiveFacetsCount;\n  /**\n   * True if the number of hits is exhaustive\n   * @member {boolean}\n   */\n\n  this.exhaustiveNbHits = mainSubResponse.exhaustiveNbHits;\n  /**\n   * Contains the userData if they are set by a [query rule](https://www.algolia.com/doc/guides/query-rules/query-rules-overview/).\n   * @member {object[]}\n   */\n\n  this.userData = mainSubResponse.userData;\n  /**\n   * queryID is the unique identifier of the query used to generate the current search results.\n   * This value is only available if the `clickAnalytics` search parameter is set to `true`.\n   * @member {string}\n   */\n\n  this.queryID = mainSubResponse.queryID;\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.Facet[]}\n   */\n\n  this.disjunctiveFacets = [];\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.HierarchicalFacet[]}\n   */\n\n  this.hierarchicalFacets = map(state.hierarchicalFacets, function initFutureTree() {\n    return [];\n  });\n  /**\n   * other facets results\n   * @member {SearchResults.Facet[]}\n   */\n\n  this.facets = [];\n  var disjunctiveFacets = state.getRefinedDisjunctiveFacets();\n  var facetsIndices = getIndices(state.facets);\n  var disjunctiveFacetsIndices = getIndices(state.disjunctiveFacets);\n  var nextDisjunctiveResult = 1;\n  var self = this; // Since we send request only for disjunctive facets that have been refined,\n  // we get the facets informations from the first, general, response.\n\n  forEach(mainSubResponse.facets, function (facetValueObject, facetKey) {\n    var hierarchicalFacet = findMatchingHierarchicalFacetFromAttributeName(state.hierarchicalFacets, facetKey);\n\n    if (hierarchicalFacet) {\n      // Place the hierarchicalFacet data at the correct index depending on\n      // the attributes order that was defined at the helper initialization\n      var facetIndex = hierarchicalFacet.attributes.indexOf(facetKey);\n      var idxAttributeName = findIndex(state.hierarchicalFacets, {\n        name: hierarchicalFacet.name\n      });\n      self.hierarchicalFacets[idxAttributeName][facetIndex] = {\n        attribute: facetKey,\n        data: facetValueObject,\n        exhaustive: mainSubResponse.exhaustiveFacetsCount\n      };\n    } else {\n      var isFacetDisjunctive = indexOf(state.disjunctiveFacets, facetKey) !== -1;\n      var isFacetConjunctive = indexOf(state.facets, facetKey) !== -1;\n      var position;\n\n      if (isFacetDisjunctive) {\n        position = disjunctiveFacetsIndices[facetKey];\n        self.disjunctiveFacets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], mainSubResponse.facets_stats, facetKey);\n      }\n\n      if (isFacetConjunctive) {\n        position = facetsIndices[facetKey];\n        self.facets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.facets[position], mainSubResponse.facets_stats, facetKey);\n      }\n    }\n  }); // Make sure we do not keep holes within the hierarchical facets\n\n  this.hierarchicalFacets = compact(this.hierarchicalFacets); // aggregate the refined disjunctive facets\n\n  forEach(disjunctiveFacets, function (disjunctiveFacet) {\n    var result = results[nextDisjunctiveResult];\n    var hierarchicalFacet = state.getHierarchicalFacetByName(disjunctiveFacet); // There should be only item in facets.\n\n    forEach(result.facets, function (facetResults, dfacet) {\n      var position;\n\n      if (hierarchicalFacet) {\n        position = findIndex(state.hierarchicalFacets, {\n          name: hierarchicalFacet.name\n        });\n        var attributeIndex = findIndex(self.hierarchicalFacets[position], {\n          attribute: dfacet\n        }); // previous refinements and no results so not able to find it\n\n        if (attributeIndex === -1) {\n          return;\n        }\n\n        self.hierarchicalFacets[position][attributeIndex].data = merge({}, self.hierarchicalFacets[position][attributeIndex].data, facetResults);\n      } else {\n        position = disjunctiveFacetsIndices[dfacet];\n        var dataFromMainRequest = mainSubResponse.facets && mainSubResponse.facets[dfacet] || {};\n        self.disjunctiveFacets[position] = {\n          name: dfacet,\n          data: defaults({}, facetResults, dataFromMainRequest),\n          exhaustive: result.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], result.facets_stats, dfacet);\n\n        if (state.disjunctiveFacetsRefinements[dfacet]) {\n          forEach(state.disjunctiveFacetsRefinements[dfacet], function (refinementValue) {\n            // add the disjunctive refinements if it is no more retrieved\n            if (!self.disjunctiveFacets[position].data[refinementValue] && indexOf(state.disjunctiveFacetsRefinements[dfacet], refinementValue) > -1) {\n              self.disjunctiveFacets[position].data[refinementValue] = 0;\n            }\n          });\n        }\n      }\n    });\n    nextDisjunctiveResult++;\n  }); // if we have some root level values for hierarchical facets, merge them\n\n  forEach(state.getRefinedHierarchicalFacets(), function (refinedFacet) {\n    var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\n\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n    var currentRefinement = state.getHierarchicalRefinement(refinedFacet); // if we are already at a root refinement (or no refinement at all), there is no\n    // root level values request\n\n    if (currentRefinement.length === 0 || currentRefinement[0].split(separator).length < 2) {\n      return;\n    }\n\n    var result = results[nextDisjunctiveResult];\n    forEach(result.facets, function (facetResults, dfacet) {\n      var position = findIndex(state.hierarchicalFacets, {\n        name: hierarchicalFacet.name\n      });\n      var attributeIndex = findIndex(self.hierarchicalFacets[position], {\n        attribute: dfacet\n      }); // previous refinements and no results so not able to find it\n\n      if (attributeIndex === -1) {\n        return;\n      } // when we always get root levels, if the hits refinement is `beers > IPA` (count: 5),\n      // then the disjunctive values will be `beers` (count: 100),\n      // but we do not want to display\n      //   | beers (100)\n      //     > IPA (5)\n      // We want\n      //   | beers (5)\n      //     > IPA (5)\n\n\n      var defaultData = {};\n\n      if (currentRefinement.length > 0) {\n        var root = currentRefinement[0].split(separator)[0];\n        defaultData[root] = self.hierarchicalFacets[position][attributeIndex].data[root];\n      }\n\n      self.hierarchicalFacets[position][attributeIndex].data = defaults(defaultData, facetResults, self.hierarchicalFacets[position][attributeIndex].data);\n    });\n    nextDisjunctiveResult++;\n  }); // add the excludes\n\n  forEach(state.facetsExcludes, function (excludes, facetName) {\n    var position = facetsIndices[facetName];\n    self.facets[position] = {\n      name: facetName,\n      data: mainSubResponse.facets[facetName],\n      exhaustive: mainSubResponse.exhaustiveFacetsCount\n    };\n    forEach(excludes, function (facetValue) {\n      self.facets[position] = self.facets[position] || {\n        name: facetName\n      };\n      self.facets[position].data = self.facets[position].data || {};\n      self.facets[position].data[facetValue] = 0;\n    });\n  });\n  this.hierarchicalFacets = map(this.hierarchicalFacets, generateHierarchicalTree(state));\n  this.facets = compact(this.facets);\n  this.disjunctiveFacets = compact(this.disjunctiveFacets);\n  this._state = state;\n}\n/**\n * Get a facet object with its name\n * @deprecated\n * @param {string} name name of the faceted attribute\n * @return {SearchResults.Facet} the facet object\n */\n\n\nSearchResults.prototype.getFacetByName = function (name) {\n  var predicate = {\n    name: name\n  };\n  return find(this.facets, predicate) || find(this.disjunctiveFacets, predicate) || find(this.hierarchicalFacets, predicate);\n};\n/**\n * Get the facet values of a specified attribute from a SearchResults object.\n * @private\n * @param {SearchResults} results the search results to search in\n * @param {string} attribute name of the faceted attribute to search for\n * @return {array|object} facet values. For the hierarchical facets it is an object.\n */\n\n\nfunction extractNormalizedFacetValues(results, attribute) {\n  var predicate = {\n    name: attribute\n  };\n\n  if (results._state.isConjunctiveFacet(attribute)) {\n    var facet = find(results.facets, predicate);\n    if (!facet) return [];\n    return map(facet.data, function (v, k) {\n      return {\n        name: k,\n        count: v,\n        isRefined: results._state.isFacetRefined(attribute, k),\n        isExcluded: results._state.isExcludeRefined(attribute, k)\n      };\n    });\n  } else if (results._state.isDisjunctiveFacet(attribute)) {\n    var disjunctiveFacet = find(results.disjunctiveFacets, predicate);\n    if (!disjunctiveFacet) return [];\n    return map(disjunctiveFacet.data, function (v, k) {\n      return {\n        name: k,\n        count: v,\n        isRefined: results._state.isDisjunctiveFacetRefined(attribute, k)\n      };\n    });\n  } else if (results._state.isHierarchicalFacet(attribute)) {\n    return find(results.hierarchicalFacets, predicate);\n  }\n}\n/**\n * Sort nodes of a hierarchical facet results\n * @private\n * @param {HierarchicalFacet} node node to upon which we want to apply the sort\n */\n\n\nfunction recSort(sortFn, node) {\n  if (!node.data || node.data.length === 0) {\n    return node;\n  }\n\n  var children = map(node.data, partial(recSort, sortFn));\n  var sortedChildren = sortFn(children);\n  var newNode = merge({}, node, {\n    data: sortedChildren\n  });\n  return newNode;\n}\n\nSearchResults.DEFAULT_SORT = ['isRefined:desc', 'count:desc', 'name:asc'];\n\nfunction vanillaSortFn(order, data) {\n  return data.sort(order);\n}\n/**\n * Get a the list of values for a given facet attribute. Those values are sorted\n * refinement first, descending count (bigger value on top), and name ascending\n * (alphabetical order). The sort formula can overridden using either string based\n * predicates or a function.\n *\n * This method will return all the values returned by the Algolia engine plus all\n * the values already refined. This means that it can happen that the\n * `maxValuesPerFacet` [configuration](https://www.algolia.com/doc/rest-api/search#param-maxValuesPerFacet)\n * might not be respected if you have facet values that are already refined.\n * @param {string} attribute attribute name\n * @param {object} opts configuration options.\n * @param {Array.<string> | function} opts.sortBy\n * When using strings, it consists of\n * the name of the [FacetValue](#SearchResults.FacetValue) or the\n * [HierarchicalFacet](#SearchResults.HierarchicalFacet) attributes with the\n * order (`asc` or `desc`). For example to order the value by count, the\n * argument would be `['count:asc']`.\n *\n * If only the attribute name is specified, the ordering defaults to the one\n * specified in the default value for this attribute.\n *\n * When not specified, the order is\n * ascending.  This parameter can also be a function which takes two facet\n * values and should return a number, 0 if equal, 1 if the first argument is\n * bigger or -1 otherwise.\n *\n * The default value for this attribute `['isRefined:desc', 'count:desc', 'name:asc']`\n * @return {FacetValue[]|HierarchicalFacet} depending on the type of facet of\n * the attribute requested (hierarchical, disjunctive or conjunctive)\n * @example\n * helper.on('results', function(content){\n *   //get values ordered only by name ascending using the string predicate\n *   content.getFacetValues('city', {sortBy: ['name:asc']});\n *   //get values  ordered only by count ascending using a function\n *   content.getFacetValues('city', {\n *     // this is equivalent to ['count:asc']\n *     sortBy: function(a, b) {\n *       if (a.count === b.count) return 0;\n *       if (a.count > b.count)   return 1;\n *       if (b.count > a.count)   return -1;\n *     }\n *   });\n * });\n */\n\n\nSearchResults.prototype.getFacetValues = function (attribute, opts) {\n  var facetValues = extractNormalizedFacetValues(this, attribute);\n  if (!facetValues) throw new Error(attribute + ' is not a retrieved facet.');\n  var options = defaults({}, opts, {\n    sortBy: SearchResults.DEFAULT_SORT\n  });\n\n  if (Array.isArray(options.sortBy)) {\n    var order = formatSort(options.sortBy, SearchResults.DEFAULT_SORT);\n\n    if (Array.isArray(facetValues)) {\n      return orderBy(facetValues, order[0], order[1]);\n    } // If facetValues is not an array, it's an object thus a hierarchical facet object\n\n\n    return recSort(partialRight(orderBy, order[0], order[1]), facetValues);\n  } else if (isFunction(options.sortBy)) {\n    if (Array.isArray(facetValues)) {\n      return facetValues.sort(options.sortBy);\n    } // If facetValues is not an array, it's an object thus a hierarchical facet object\n\n\n    return recSort(partial(vanillaSortFn, options.sortBy), facetValues);\n  }\n\n  throw new Error('options.sortBy is optional but if defined it must be ' + 'either an array of string (predicates) or a sorting function');\n};\n/**\n * Returns the facet stats if attribute is defined and the facet contains some.\n * Otherwise returns undefined.\n * @param {string} attribute name of the faceted attribute\n * @return {object} The stats of the facet\n */\n\n\nSearchResults.prototype.getFacetStats = function (attribute) {\n  if (this._state.isConjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.facets, attribute);\n  } else if (this._state.isDisjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.disjunctiveFacets, attribute);\n  }\n\n  throw new Error(attribute + ' is not present in `facets` or `disjunctiveFacets`');\n};\n\nfunction getFacetStatsIfAvailable(facetList, facetName) {\n  var data = find(facetList, {\n    name: facetName\n  });\n  return data && data.stats;\n}\n/**\n * Returns all refinements for all filters + tags. It also provides\n * additional information: count and exhausistivity for each filter.\n *\n * See the [refinement type](#Refinement) for an exhaustive view of the available\n * data.\n *\n * @return {Array.<Refinement>} all the refinements\n */\n\n\nSearchResults.prototype.getRefinements = function () {\n  var state = this._state;\n  var results = this;\n  var res = [];\n  forEach(state.facetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));\n    });\n  });\n  forEach(state.facetsExcludes, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'exclude', attributeName, name, results.facets));\n    });\n  });\n  forEach(state.disjunctiveFacetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'disjunctive', attributeName, name, results.disjunctiveFacets));\n    });\n  });\n  forEach(state.hierarchicalFacetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getHierarchicalRefinement(state, attributeName, name, results.hierarchicalFacets));\n    });\n  });\n  forEach(state.numericRefinements, function (operators, attributeName) {\n    forEach(operators, function (values, operator) {\n      forEach(values, function (value) {\n        res.push({\n          type: 'numeric',\n          attributeName: attributeName,\n          name: value,\n          numericValue: value,\n          operator: operator\n        });\n      });\n    });\n  });\n  forEach(state.tagRefinements, function (name) {\n    res.push({\n      type: 'tag',\n      attributeName: '_tags',\n      name: name\n    });\n  });\n  return res;\n};\n\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n  var facet = find(resultsFacets, {\n    name: attributeName\n  });\n  var count = get(facet, 'data[' + name + ']');\n  var exhaustive = get(facet, 'exhaustive');\n  return {\n    type: type,\n    attributeName: attributeName,\n    name: name,\n    count: count || 0,\n    exhaustive: exhaustive || false\n  };\n}\n\nfunction getHierarchicalRefinement(state, attributeName, name, resultsFacets) {\n  var facet = find(resultsFacets, {\n    name: attributeName\n  });\n  var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n  var splitted = name.split(facetDeclaration.separator);\n  var configuredName = splitted[splitted.length - 1];\n\n  for (var i = 0; facet !== undefined && i < splitted.length; ++i) {\n    facet = find(facet.data, {\n      name: splitted[i]\n    });\n  }\n\n  var count = get(facet, 'count');\n  var exhaustive = get(facet, 'exhaustive');\n  return {\n    type: 'hierarchical',\n    attributeName: attributeName,\n    name: configuredName,\n    count: count || 0,\n    exhaustive: exhaustive || false\n  };\n}\n\nmodule.exports = SearchResults;","map":{"version":3,"sources":["D:/TT18-EC-Team1-FE/isomorphic/node_modules/algoliasearch-helper/src/SearchResults/index.js"],"names":["forEach","require","compact","indexOf","findIndex","get","sumBy","find","includes","map","orderBy","defaults","merge","isFunction","partial","partialRight","formatSort","generateHierarchicalTree","getIndices","obj","indices","val","idx","assignFacetStats","dest","facetStats","key","stats","findMatchingHierarchicalFacetFromAttributeName","hierarchicalFacets","hierarchicalAttributeName","facetKeyMatchesAttribute","hierarchicalFacet","attributes","SearchResults","state","results","mainSubResponse","_rawResults","query","parsedQuery","hits","index","hitsPerPage","nbHits","nbPages","page","processingTimeMS","aroundLatLng","automaticRadius","serverUsed","timeoutCounts","timeoutHits","exhaustiveFacetsCount","exhaustiveNbHits","userData","queryID","disjunctiveFacets","initFutureTree","facets","getRefinedDisjunctiveFacets","facetsIndices","disjunctiveFacetsIndices","nextDisjunctiveResult","self","facetValueObject","facetKey","facetIndex","idxAttributeName","name","attribute","data","exhaustive","isFacetDisjunctive","isFacetConjunctive","position","facets_stats","disjunctiveFacet","result","getHierarchicalFacetByName","facetResults","dfacet","attributeIndex","dataFromMainRequest","disjunctiveFacetsRefinements","refinementValue","getRefinedHierarchicalFacets","refinedFacet","separator","_getHierarchicalFacetSeparator","currentRefinement","getHierarchicalRefinement","length","split","defaultData","root","facetsExcludes","excludes","facetName","facetValue","_state","prototype","getFacetByName","predicate","extractNormalizedFacetValues","isConjunctiveFacet","facet","v","k","count","isRefined","isFacetRefined","isExcluded","isExcludeRefined","isDisjunctiveFacet","isDisjunctiveFacetRefined","isHierarchicalFacet","recSort","sortFn","node","children","sortedChildren","newNode","DEFAULT_SORT","vanillaSortFn","order","sort","getFacetValues","opts","facetValues","Error","options","sortBy","Array","isArray","getFacetStats","getFacetStatsIfAvailable","facetList","getRefinements","res","facetsRefinements","refinements","attributeName","push","getRefinement","hierarchicalFacetsRefinements","numericRefinements","operators","values","operator","value","type","numericValue","tagRefinements","resultsFacets","facetDeclaration","splitted","configuredName","i","undefined","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIG,SAAS,GAAGH,OAAO,CAAC,kBAAD,CAAvB;;AACA,IAAII,GAAG,GAAGJ,OAAO,CAAC,YAAD,CAAjB;;AAEA,IAAIK,KAAK,GAAGL,OAAO,CAAC,cAAD,CAAnB;;AACA,IAAIM,IAAI,GAAGN,OAAO,CAAC,aAAD,CAAlB;;AACA,IAAIO,QAAQ,GAAGP,OAAO,CAAC,iBAAD,CAAtB;;AACA,IAAIQ,GAAG,GAAGR,OAAO,CAAC,YAAD,CAAjB;;AACA,IAAIS,OAAO,GAAGT,OAAO,CAAC,gBAAD,CAArB;;AAEA,IAAIU,QAAQ,GAAGV,OAAO,CAAC,iBAAD,CAAtB;;AACA,IAAIW,KAAK,GAAGX,OAAO,CAAC,cAAD,CAAnB;;AAEA,IAAIY,UAAU,GAAGZ,OAAO,CAAC,mBAAD,CAAxB;;AAEA,IAAIa,OAAO,GAAGb,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIc,YAAY,GAAGd,OAAO,CAAC,qBAAD,CAA1B;;AAEA,IAAIe,UAAU,GAAGf,OAAO,CAAC,yBAAD,CAAxB;;AAEA,IAAIgB,wBAAwB,GAAGhB,OAAO,CAAC,8BAAD,CAAtC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASiB,UAAT,CAAoBC,GAApB,EAAyB;AACvB,MAAIC,OAAO,GAAG,EAAd;AAEApB,EAAAA,OAAO,CAACmB,GAAD,EAAM,UAASE,GAAT,EAAcC,GAAd,EAAmB;AAAEF,IAAAA,OAAO,CAACC,GAAD,CAAP,GAAeC,GAAf;AAAqB,GAAhD,CAAP;AAEA,SAAOF,OAAP;AACD;;AAED,SAASG,gBAAT,CAA0BC,IAA1B,EAAgCC,UAAhC,EAA4CC,GAA5C,EAAiD;AAC/C,MAAID,UAAU,IAAIA,UAAU,CAACC,GAAD,CAA5B,EAAmC;AACjCF,IAAAA,IAAI,CAACG,KAAL,GAAaF,UAAU,CAACC,GAAD,CAAvB;AACD;AACF;;AAED,SAASE,8CAAT,CAAwDC,kBAAxD,EAA4EC,yBAA5E,EAAuG;AACrG,SAAOvB,IAAI,CACTsB,kBADS,EAET,SAASE,wBAAT,CAAkCC,iBAAlC,EAAqD;AACnD,WAAOxB,QAAQ,CAACwB,iBAAiB,CAACC,UAAnB,EAA+BH,yBAA/B,CAAf;AACD,GAJQ,CAAX;AAMD;AAED;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA,SAASI,aAAT,CAAuBC,KAAvB,EAA8BC,OAA9B,EAAuC;AACrC,MAAIC,eAAe,GAAGD,OAAO,CAAC,CAAD,CAA7B;AAEA,OAAKE,WAAL,GAAmBF,OAAnB;AAEA;AACF;AACA;AACA;;AACE,OAAKG,KAAL,GAAaF,eAAe,CAACE,KAA7B;AACA;AACF;AACA;AACA;;AACE,OAAKC,WAAL,GAAmBH,eAAe,CAACG,WAAnC;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,IAAL,GAAYJ,eAAe,CAACI,IAA5B;AACA;AACF;AACA;AACA;;AACE,OAAKC,KAAL,GAAaL,eAAe,CAACK,KAA7B;AACA;AACF;AACA;AACA;;AACE,OAAKC,WAAL,GAAmBN,eAAe,CAACM,WAAnC;AACA;AACF;AACA;AACA;;AACE,OAAKC,MAAL,GAAcP,eAAe,CAACO,MAA9B;AACA;AACF;AACA;AACA;;AACE,OAAKC,OAAL,GAAeR,eAAe,CAACQ,OAA/B;AACA;AACF;AACA;AACA;;AACE,OAAKC,IAAL,GAAYT,eAAe,CAACS,IAA5B;AACA;AACF;AACA;AACA;;AACE,OAAKC,gBAAL,GAAwBzC,KAAK,CAAC8B,OAAD,EAAU,kBAAV,CAA7B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKY,YAAL,GAAoBX,eAAe,CAACW,YAApC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,eAAL,GAAuBZ,eAAe,CAACY,eAAvC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkBb,eAAe,CAACa,UAAlC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,aAAL,GAAqBd,eAAe,CAACc,aAArC;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,WAAL,GAAmBf,eAAe,CAACe,WAAnC;AAEA;AACF;AACA;AACA;;AACE,OAAKC,qBAAL,GAA6BhB,eAAe,CAACgB,qBAA7C;AAEA;AACF;AACA;AACA;;AACE,OAAKC,gBAAL,GAAwBjB,eAAe,CAACiB,gBAAxC;AAGA;AACF;AACA;AACA;;AACE,OAAKC,QAAL,GAAgBlB,eAAe,CAACkB,QAAhC;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,OAAL,GAAenB,eAAe,CAACmB,OAA/B;AAEA;AACF;AACA;AACA;;AACE,OAAKC,iBAAL,GAAyB,EAAzB;AACA;AACF;AACA;AACA;;AACE,OAAK5B,kBAAL,GAA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","sourcesContent":["'use strict';\n\nvar forEach = require('lodash/forEach');\nvar compact = require('lodash/compact');\nvar indexOf = require('lodash/indexOf');\nvar findIndex = require('lodash/findIndex');\nvar get = require('lodash/get');\n\nvar sumBy = require('lodash/sumBy');\nvar find = require('lodash/find');\nvar includes = require('lodash/includes');\nvar map = require('lodash/map');\nvar orderBy = require('lodash/orderBy');\n\nvar defaults = require('lodash/defaults');\nvar merge = require('lodash/merge');\n\nvar isFunction = require('lodash/isFunction');\n\nvar partial = require('lodash/partial');\nvar partialRight = require('lodash/partialRight');\n\nvar formatSort = require('../functions/formatSort');\n\nvar generateHierarchicalTree = require('./generate-hierarchical-tree');\n\n/**\n * @typedef SearchResults.Facet\n * @type {object}\n * @property {string} name name of the attribute in the record\n * @property {object} data the faceting data: value, number of entries\n * @property {object} stats undefined unless facet_stats is retrieved from algolia\n */\n\n/**\n * @typedef SearchResults.HierarchicalFacet\n * @type {object}\n * @property {string} name name of the current value given the hierarchical level, trimmed.\n * If root node, you get the facet name\n * @property {number} count number of objects matching this hierarchical value\n * @property {string} path the current hierarchical value full path\n * @property {boolean} isRefined `true` if the current value was refined, `false` otherwise\n * @property {HierarchicalFacet[]} data sub values for the current level\n */\n\n/**\n * @typedef SearchResults.FacetValue\n * @type {object}\n * @property {string} name the facet value itself\n * @property {number} count times this facet appears in the results\n * @property {boolean} isRefined is the facet currently selected\n * @property {boolean} isExcluded is the facet currently excluded (only for conjunctive facets)\n */\n\n/**\n * @typedef Refinement\n * @type {object}\n * @property {string} type the type of filter used:\n * `numeric`, `facet`, `exclude`, `disjunctive`, `hierarchical`\n * @property {string} attributeName name of the attribute used for filtering\n * @property {string} name the value of the filter\n * @property {number} numericValue the value as a number. Only for numeric filters.\n * @property {string} operator the operator used. Only for numeric filters.\n * @property {number} count the number of computed hits for this filter. Only on facets.\n * @property {boolean} exhaustive if the count is exhaustive\n */\n\nfunction getIndices(obj) {\n  var indices = {};\n\n  forEach(obj, function(val, idx) { indices[val] = idx; });\n\n  return indices;\n}\n\nfunction assignFacetStats(dest, facetStats, key) {\n  if (facetStats && facetStats[key]) {\n    dest.stats = facetStats[key];\n  }\n}\n\nfunction findMatchingHierarchicalFacetFromAttributeName(hierarchicalFacets, hierarchicalAttributeName) {\n  return find(\n    hierarchicalFacets,\n    function facetKeyMatchesAttribute(hierarchicalFacet) {\n      return includes(hierarchicalFacet.attributes, hierarchicalAttributeName);\n    }\n  );\n}\n\n/*eslint-disable */\n/**\n * Constructor for SearchResults\n * @class\n * @classdesc SearchResults contains the results of a query to Algolia using the\n * {@link AlgoliaSearchHelper}.\n * @param {SearchParameters} state state that led to the response\n * @param {array.<object>} results the results from algolia client\n * @example <caption>SearchResults of the first query in\n * <a href=\"http://demos.algolia.com/instant-search-demo\">the instant search demo</a></caption>\n{\n   \"hitsPerPage\": 10,\n   \"processingTimeMS\": 2,\n   \"facets\": [\n      {\n         \"name\": \"type\",\n         \"data\": {\n            \"HardGood\": 6627,\n            \"BlackTie\": 550,\n            \"Music\": 665,\n            \"Software\": 131,\n            \"Game\": 456,\n            \"Movie\": 1571\n         },\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"Free shipping\": 5507\n         },\n         \"name\": \"shipping\"\n      }\n  ],\n   \"hits\": [\n      {\n         \"thumbnailImage\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_54x108_s.gif\",\n         \"_highlightResult\": {\n            \"shortDescription\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n               \"matchedWords\": []\n            },\n            \"category\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Computer Security Software\",\n               \"matchedWords\": []\n            },\n            \"manufacturer\": {\n               \"matchedWords\": [],\n               \"value\": \"Webroot\",\n               \"matchLevel\": \"none\"\n            },\n            \"name\": {\n               \"value\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n               \"matchedWords\": [],\n               \"matchLevel\": \"none\"\n            }\n         },\n         \"image\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_105x210_sc.jpg\",\n         \"shipping\": \"Free shipping\",\n         \"bestSellingRank\": 4,\n         \"shortDescription\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n         \"url\": \"http://www.bestbuy.com/site/webroot-secureanywhere-internet-security-3-devi…d=1219060687969&skuId=1688832&cmp=RMX&ky=2d3GfEmNIzjA0vkzveHdZEBgpPCyMnLTJ\",\n         \"name\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n         \"category\": \"Computer Security Software\",\n         \"salePrice_range\": \"1 - 50\",\n         \"objectID\": \"1688832\",\n         \"type\": \"Software\",\n         \"customerReviewCount\": 5980,\n         \"salePrice\": 49.99,\n         \"manufacturer\": \"Webroot\"\n      },\n      ....\n  ],\n   \"nbHits\": 10000,\n   \"disjunctiveFacets\": [\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"5\": 183,\n            \"12\": 112,\n            \"7\": 149,\n            ...\n         },\n         \"name\": \"customerReviewCount\",\n         \"stats\": {\n            \"max\": 7461,\n            \"avg\": 157.939,\n            \"min\": 1\n         }\n      },\n      {\n         \"data\": {\n            \"Printer Ink\": 142,\n            \"Wireless Speakers\": 60,\n            \"Point & Shoot Cameras\": 48,\n            ...\n         },\n         \"name\": \"category\",\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"> 5000\": 2,\n            \"1 - 50\": 6524,\n            \"501 - 2000\": 566,\n            \"201 - 500\": 1501,\n            \"101 - 200\": 1360,\n            \"2001 - 5000\": 47\n         },\n         \"name\": \"salePrice_range\"\n      },\n      {\n         \"data\": {\n            \"Dynex™\": 202,\n            \"Insignia™\": 230,\n            \"PNY\": 72,\n            ...\n         },\n         \"name\": \"manufacturer\",\n         \"exhaustive\": false\n      }\n  ],\n   \"query\": \"\",\n   \"nbPages\": 100,\n   \"page\": 0,\n   \"index\": \"bestbuy\"\n}\n **/\n/*eslint-enable */\nfunction SearchResults(state, results) {\n  var mainSubResponse = results[0];\n\n  this._rawResults = results;\n\n  /**\n   * query used to generate the results\n   * @member {string}\n   */\n  this.query = mainSubResponse.query;\n  /**\n   * The query as parsed by the engine given all the rules.\n   * @member {string}\n   */\n  this.parsedQuery = mainSubResponse.parsedQuery;\n  /**\n   * all the records that match the search parameters. Each record is\n   * augmented with a new attribute `_highlightResult`\n   * which is an object keyed by attribute and with the following properties:\n   *  - `value` : the value of the facet highlighted (html)\n   *  - `matchLevel`: full, partial or none depending on how the query terms match\n   * @member {object[]}\n   */\n  this.hits = mainSubResponse.hits;\n  /**\n   * index where the results come from\n   * @member {string}\n   */\n  this.index = mainSubResponse.index;\n  /**\n   * number of hits per page requested\n   * @member {number}\n   */\n  this.hitsPerPage = mainSubResponse.hitsPerPage;\n  /**\n   * total number of hits of this query on the index\n   * @member {number}\n   */\n  this.nbHits = mainSubResponse.nbHits;\n  /**\n   * total number of pages with respect to the number of hits per page and the total number of hits\n   * @member {number}\n   */\n  this.nbPages = mainSubResponse.nbPages;\n  /**\n   * current page\n   * @member {number}\n   */\n  this.page = mainSubResponse.page;\n  /**\n   * sum of the processing time of all the queries\n   * @member {number}\n   */\n  this.processingTimeMS = sumBy(results, 'processingTimeMS');\n  /**\n   * The position if the position was guessed by IP.\n   * @member {string}\n   * @example \"48.8637,2.3615\",\n   */\n  this.aroundLatLng = mainSubResponse.aroundLatLng;\n  /**\n   * The radius computed by Algolia.\n   * @member {string}\n   * @example \"126792922\",\n   */\n  this.automaticRadius = mainSubResponse.automaticRadius;\n  /**\n   * String identifying the server used to serve this request.\n   * @member {string}\n   * @example \"c7-use-2.algolia.net\",\n   */\n  this.serverUsed = mainSubResponse.serverUsed;\n  /**\n   * Boolean that indicates if the computation of the counts did time out.\n   * @deprecated\n   * @member {boolean}\n   */\n  this.timeoutCounts = mainSubResponse.timeoutCounts;\n  /**\n   * Boolean that indicates if the computation of the hits did time out.\n   * @deprecated\n   * @member {boolean}\n   */\n  this.timeoutHits = mainSubResponse.timeoutHits;\n\n  /**\n   * True if the counts of the facets is exhaustive\n   * @member {boolean}\n   */\n  this.exhaustiveFacetsCount = mainSubResponse.exhaustiveFacetsCount;\n\n  /**\n   * True if the number of hits is exhaustive\n   * @member {boolean}\n   */\n  this.exhaustiveNbHits = mainSubResponse.exhaustiveNbHits;\n\n\n  /**\n   * Contains the userData if they are set by a [query rule](https://www.algolia.com/doc/guides/query-rules/query-rules-overview/).\n   * @member {object[]}\n   */\n  this.userData = mainSubResponse.userData;\n\n  /**\n   * queryID is the unique identifier of the query used to generate the current search results.\n   * This value is only available if the `clickAnalytics` search parameter is set to `true`.\n   * @member {string}\n   */\n  this.queryID = mainSubResponse.queryID;\n\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.Facet[]}\n   */\n  this.disjunctiveFacets = [];\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.HierarchicalFacet[]}\n   */\n  this.hierarchicalFacets = map(state.hierarchicalFacets, function initFutureTree() {\n    return [];\n  });\n  /**\n   * other facets results\n   * @member {SearchResults.Facet[]}\n   */\n  this.facets = [];\n\n  var disjunctiveFacets = state.getRefinedDisjunctiveFacets();\n\n  var facetsIndices = getIndices(state.facets);\n  var disjunctiveFacetsIndices = getIndices(state.disjunctiveFacets);\n  var nextDisjunctiveResult = 1;\n\n  var self = this;\n  // Since we send request only for disjunctive facets that have been refined,\n  // we get the facets informations from the first, general, response.\n  forEach(mainSubResponse.facets, function(facetValueObject, facetKey) {\n    var hierarchicalFacet = findMatchingHierarchicalFacetFromAttributeName(\n      state.hierarchicalFacets,\n      facetKey\n    );\n\n    if (hierarchicalFacet) {\n      // Place the hierarchicalFacet data at the correct index depending on\n      // the attributes order that was defined at the helper initialization\n      var facetIndex = hierarchicalFacet.attributes.indexOf(facetKey);\n      var idxAttributeName = findIndex(state.hierarchicalFacets, {name: hierarchicalFacet.name});\n      self.hierarchicalFacets[idxAttributeName][facetIndex] = {\n        attribute: facetKey,\n        data: facetValueObject,\n        exhaustive: mainSubResponse.exhaustiveFacetsCount\n      };\n    } else {\n      var isFacetDisjunctive = indexOf(state.disjunctiveFacets, facetKey) !== -1;\n      var isFacetConjunctive = indexOf(state.facets, facetKey) !== -1;\n      var position;\n\n      if (isFacetDisjunctive) {\n        position = disjunctiveFacetsIndices[facetKey];\n        self.disjunctiveFacets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], mainSubResponse.facets_stats, facetKey);\n      }\n      if (isFacetConjunctive) {\n        position = facetsIndices[facetKey];\n        self.facets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.facets[position], mainSubResponse.facets_stats, facetKey);\n      }\n    }\n  });\n\n  // Make sure we do not keep holes within the hierarchical facets\n  this.hierarchicalFacets = compact(this.hierarchicalFacets);\n\n  // aggregate the refined disjunctive facets\n  forEach(disjunctiveFacets, function(disjunctiveFacet) {\n    var result = results[nextDisjunctiveResult];\n    var hierarchicalFacet = state.getHierarchicalFacetByName(disjunctiveFacet);\n\n    // There should be only item in facets.\n    forEach(result.facets, function(facetResults, dfacet) {\n      var position;\n\n      if (hierarchicalFacet) {\n        position = findIndex(state.hierarchicalFacets, {name: hierarchicalFacet.name});\n        var attributeIndex = findIndex(self.hierarchicalFacets[position], {attribute: dfacet});\n\n        // previous refinements and no results so not able to find it\n        if (attributeIndex === -1) {\n          return;\n        }\n\n        self.hierarchicalFacets[position][attributeIndex].data = merge(\n          {},\n          self.hierarchicalFacets[position][attributeIndex].data,\n          facetResults\n        );\n      } else {\n        position = disjunctiveFacetsIndices[dfacet];\n\n        var dataFromMainRequest = mainSubResponse.facets && mainSubResponse.facets[dfacet] || {};\n\n        self.disjunctiveFacets[position] = {\n          name: dfacet,\n          data: defaults({}, facetResults, dataFromMainRequest),\n          exhaustive: result.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], result.facets_stats, dfacet);\n\n        if (state.disjunctiveFacetsRefinements[dfacet]) {\n          forEach(state.disjunctiveFacetsRefinements[dfacet], function(refinementValue) {\n            // add the disjunctive refinements if it is no more retrieved\n            if (!self.disjunctiveFacets[position].data[refinementValue] &&\n              indexOf(state.disjunctiveFacetsRefinements[dfacet], refinementValue) > -1) {\n              self.disjunctiveFacets[position].data[refinementValue] = 0;\n            }\n          });\n        }\n      }\n    });\n    nextDisjunctiveResult++;\n  });\n\n  // if we have some root level values for hierarchical facets, merge them\n  forEach(state.getRefinedHierarchicalFacets(), function(refinedFacet) {\n    var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n    var currentRefinement = state.getHierarchicalRefinement(refinedFacet);\n    // if we are already at a root refinement (or no refinement at all), there is no\n    // root level values request\n    if (currentRefinement.length === 0 || currentRefinement[0].split(separator).length < 2) {\n      return;\n    }\n\n    var result = results[nextDisjunctiveResult];\n\n    forEach(result.facets, function(facetResults, dfacet) {\n      var position = findIndex(state.hierarchicalFacets, {name: hierarchicalFacet.name});\n      var attributeIndex = findIndex(self.hierarchicalFacets[position], {attribute: dfacet});\n\n      // previous refinements and no results so not able to find it\n      if (attributeIndex === -1) {\n        return;\n      }\n\n      // when we always get root levels, if the hits refinement is `beers > IPA` (count: 5),\n      // then the disjunctive values will be `beers` (count: 100),\n      // but we do not want to display\n      //   | beers (100)\n      //     > IPA (5)\n      // We want\n      //   | beers (5)\n      //     > IPA (5)\n      var defaultData = {};\n\n      if (currentRefinement.length > 0) {\n        var root = currentRefinement[0].split(separator)[0];\n        defaultData[root] = self.hierarchicalFacets[position][attributeIndex].data[root];\n      }\n\n      self.hierarchicalFacets[position][attributeIndex].data = defaults(\n        defaultData,\n        facetResults,\n        self.hierarchicalFacets[position][attributeIndex].data\n      );\n    });\n\n    nextDisjunctiveResult++;\n  });\n\n  // add the excludes\n  forEach(state.facetsExcludes, function(excludes, facetName) {\n    var position = facetsIndices[facetName];\n\n    self.facets[position] = {\n      name: facetName,\n      data: mainSubResponse.facets[facetName],\n      exhaustive: mainSubResponse.exhaustiveFacetsCount\n    };\n    forEach(excludes, function(facetValue) {\n      self.facets[position] = self.facets[position] || {name: facetName};\n      self.facets[position].data = self.facets[position].data || {};\n      self.facets[position].data[facetValue] = 0;\n    });\n  });\n\n  this.hierarchicalFacets = map(this.hierarchicalFacets, generateHierarchicalTree(state));\n\n  this.facets = compact(this.facets);\n  this.disjunctiveFacets = compact(this.disjunctiveFacets);\n\n  this._state = state;\n}\n\n/**\n * Get a facet object with its name\n * @deprecated\n * @param {string} name name of the faceted attribute\n * @return {SearchResults.Facet} the facet object\n */\nSearchResults.prototype.getFacetByName = function(name) {\n  var predicate = {name: name};\n\n  return find(this.facets, predicate) ||\n    find(this.disjunctiveFacets, predicate) ||\n    find(this.hierarchicalFacets, predicate);\n};\n\n/**\n * Get the facet values of a specified attribute from a SearchResults object.\n * @private\n * @param {SearchResults} results the search results to search in\n * @param {string} attribute name of the faceted attribute to search for\n * @return {array|object} facet values. For the hierarchical facets it is an object.\n */\nfunction extractNormalizedFacetValues(results, attribute) {\n  var predicate = {name: attribute};\n  if (results._state.isConjunctiveFacet(attribute)) {\n    var facet = find(results.facets, predicate);\n    if (!facet) return [];\n\n    return map(facet.data, function(v, k) {\n      return {\n        name: k,\n        count: v,\n        isRefined: results._state.isFacetRefined(attribute, k),\n        isExcluded: results._state.isExcludeRefined(attribute, k)\n      };\n    });\n  } else if (results._state.isDisjunctiveFacet(attribute)) {\n    var disjunctiveFacet = find(results.disjunctiveFacets, predicate);\n    if (!disjunctiveFacet) return [];\n\n    return map(disjunctiveFacet.data, function(v, k) {\n      return {\n        name: k,\n        count: v,\n        isRefined: results._state.isDisjunctiveFacetRefined(attribute, k)\n      };\n    });\n  } else if (results._state.isHierarchicalFacet(attribute)) {\n    return find(results.hierarchicalFacets, predicate);\n  }\n}\n\n/**\n * Sort nodes of a hierarchical facet results\n * @private\n * @param {HierarchicalFacet} node node to upon which we want to apply the sort\n */\nfunction recSort(sortFn, node) {\n  if (!node.data || node.data.length === 0) {\n    return node;\n  }\n  var children = map(node.data, partial(recSort, sortFn));\n  var sortedChildren = sortFn(children);\n  var newNode = merge({}, node, {data: sortedChildren});\n  return newNode;\n}\n\nSearchResults.DEFAULT_SORT = ['isRefined:desc', 'count:desc', 'name:asc'];\n\nfunction vanillaSortFn(order, data) {\n  return data.sort(order);\n}\n\n/**\n * Get a the list of values for a given facet attribute. Those values are sorted\n * refinement first, descending count (bigger value on top), and name ascending\n * (alphabetical order). The sort formula can overridden using either string based\n * predicates or a function.\n *\n * This method will return all the values returned by the Algolia engine plus all\n * the values already refined. This means that it can happen that the\n * `maxValuesPerFacet` [configuration](https://www.algolia.com/doc/rest-api/search#param-maxValuesPerFacet)\n * might not be respected if you have facet values that are already refined.\n * @param {string} attribute attribute name\n * @param {object} opts configuration options.\n * @param {Array.<string> | function} opts.sortBy\n * When using strings, it consists of\n * the name of the [FacetValue](#SearchResults.FacetValue) or the\n * [HierarchicalFacet](#SearchResults.HierarchicalFacet) attributes with the\n * order (`asc` or `desc`). For example to order the value by count, the\n * argument would be `['count:asc']`.\n *\n * If only the attribute name is specified, the ordering defaults to the one\n * specified in the default value for this attribute.\n *\n * When not specified, the order is\n * ascending.  This parameter can also be a function which takes two facet\n * values and should return a number, 0 if equal, 1 if the first argument is\n * bigger or -1 otherwise.\n *\n * The default value for this attribute `['isRefined:desc', 'count:desc', 'name:asc']`\n * @return {FacetValue[]|HierarchicalFacet} depending on the type of facet of\n * the attribute requested (hierarchical, disjunctive or conjunctive)\n * @example\n * helper.on('results', function(content){\n *   //get values ordered only by name ascending using the string predicate\n *   content.getFacetValues('city', {sortBy: ['name:asc']});\n *   //get values  ordered only by count ascending using a function\n *   content.getFacetValues('city', {\n *     // this is equivalent to ['count:asc']\n *     sortBy: function(a, b) {\n *       if (a.count === b.count) return 0;\n *       if (a.count > b.count)   return 1;\n *       if (b.count > a.count)   return -1;\n *     }\n *   });\n * });\n */\nSearchResults.prototype.getFacetValues = function(attribute, opts) {\n  var facetValues = extractNormalizedFacetValues(this, attribute);\n  if (!facetValues) throw new Error(attribute + ' is not a retrieved facet.');\n\n  var options = defaults({}, opts, {sortBy: SearchResults.DEFAULT_SORT});\n\n  if (Array.isArray(options.sortBy)) {\n    var order = formatSort(options.sortBy, SearchResults.DEFAULT_SORT);\n    if (Array.isArray(facetValues)) {\n      return orderBy(facetValues, order[0], order[1]);\n    }\n    // If facetValues is not an array, it's an object thus a hierarchical facet object\n    return recSort(partialRight(orderBy, order[0], order[1]), facetValues);\n  } else if (isFunction(options.sortBy)) {\n    if (Array.isArray(facetValues)) {\n      return facetValues.sort(options.sortBy);\n    }\n    // If facetValues is not an array, it's an object thus a hierarchical facet object\n    return recSort(partial(vanillaSortFn, options.sortBy), facetValues);\n  }\n  throw new Error(\n    'options.sortBy is optional but if defined it must be ' +\n    'either an array of string (predicates) or a sorting function'\n  );\n};\n\n/**\n * Returns the facet stats if attribute is defined and the facet contains some.\n * Otherwise returns undefined.\n * @param {string} attribute name of the faceted attribute\n * @return {object} The stats of the facet\n */\nSearchResults.prototype.getFacetStats = function(attribute) {\n  if (this._state.isConjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.facets, attribute);\n  } else if (this._state.isDisjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.disjunctiveFacets, attribute);\n  }\n\n  throw new Error(attribute + ' is not present in `facets` or `disjunctiveFacets`');\n};\n\nfunction getFacetStatsIfAvailable(facetList, facetName) {\n  var data = find(facetList, {name: facetName});\n  return data && data.stats;\n}\n\n/**\n * Returns all refinements for all filters + tags. It also provides\n * additional information: count and exhausistivity for each filter.\n *\n * See the [refinement type](#Refinement) for an exhaustive view of the available\n * data.\n *\n * @return {Array.<Refinement>} all the refinements\n */\nSearchResults.prototype.getRefinements = function() {\n  var state = this._state;\n  var results = this;\n  var res = [];\n\n  forEach(state.facetsRefinements, function(refinements, attributeName) {\n    forEach(refinements, function(name) {\n      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));\n    });\n  });\n\n  forEach(state.facetsExcludes, function(refinements, attributeName) {\n    forEach(refinements, function(name) {\n      res.push(getRefinement(state, 'exclude', attributeName, name, results.facets));\n    });\n  });\n\n  forEach(state.disjunctiveFacetsRefinements, function(refinements, attributeName) {\n    forEach(refinements, function(name) {\n      res.push(getRefinement(state, 'disjunctive', attributeName, name, results.disjunctiveFacets));\n    });\n  });\n\n  forEach(state.hierarchicalFacetsRefinements, function(refinements, attributeName) {\n    forEach(refinements, function(name) {\n      res.push(getHierarchicalRefinement(state, attributeName, name, results.hierarchicalFacets));\n    });\n  });\n\n  forEach(state.numericRefinements, function(operators, attributeName) {\n    forEach(operators, function(values, operator) {\n      forEach(values, function(value) {\n        res.push({\n          type: 'numeric',\n          attributeName: attributeName,\n          name: value,\n          numericValue: value,\n          operator: operator\n        });\n      });\n    });\n  });\n\n  forEach(state.tagRefinements, function(name) {\n    res.push({type: 'tag', attributeName: '_tags', name: name});\n  });\n\n  return res;\n};\n\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n  var facet = find(resultsFacets, {name: attributeName});\n  var count = get(facet, 'data[' + name + ']');\n  var exhaustive = get(facet, 'exhaustive');\n  return {\n    type: type,\n    attributeName: attributeName,\n    name: name,\n    count: count || 0,\n    exhaustive: exhaustive || false\n  };\n}\n\nfunction getHierarchicalRefinement(state, attributeName, name, resultsFacets) {\n  var facet = find(resultsFacets, {name: attributeName});\n  var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n  var splitted = name.split(facetDeclaration.separator);\n  var configuredName = splitted[splitted.length - 1];\n  for (var i = 0; facet !== undefined && i < splitted.length; ++i) {\n    facet = find(facet.data, {name: splitted[i]});\n  }\n  var count = get(facet, 'count');\n  var exhaustive = get(facet, 'exhaustive');\n  return {\n    type: 'hierarchical',\n    attributeName: attributeName,\n    name: configuredName,\n    count: count || 0,\n    exhaustive: exhaustive || false\n  };\n}\n\nmodule.exports = SearchResults;\n"]},"metadata":{},"sourceType":"script"}