{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _isFinite3 = require('lodash/isFinite');\n\nvar _isFinite4 = _interopRequireDefault(_isFinite3);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _indexUtils = require('../core/indexUtils');\n\nvar _createConnector = require('../core/createConnector');\n\nvar _createConnector2 = _interopRequireDefault(_createConnector);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * connectRange connector provides the logic to create connected\n * components that will give the ability for a user to refine results using\n * a numeric range.\n * @name connectRange\n * @kind connector\n * @requirements The attribute passed to the `attributeName` prop must be holding numerical values.\n * @propType {string} attributeName - Name of the attribute for faceting\n * @propType {{min?: number, max?: number}} [defaultRefinement] - Default searchState of the widget containing the start and the end of the range.\n * @propType {number} [min] - Minimum value. When this isn't set, the minimum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [max] - Maximum value. When this isn't set, the maximum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [precision=2] - Number of digits after decimal point to use.\n * @providedPropType {function} refine - a function to select a range.\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n * @providedPropType {number} min - the minimum value available.\n * @providedPropType {number} max - the maximum value available.\n * @providedPropType {number} precision - Number of digits after decimal point to use.\n */\n\n\nfunction getId(props) {\n  return props.attributeName;\n}\n\nvar namespace = 'range';\n\nfunction getCurrentRange(boundaries, stats, precision) {\n  var pow = Math.pow(10, precision);\n  var min = void 0;\n\n  if ((0, _isFinite4.default)(boundaries.min)) {\n    min = boundaries.min;\n  } else if ((0, _isFinite4.default)(stats.min)) {\n    min = stats.min;\n  } else {\n    min = undefined;\n  }\n\n  var max = void 0;\n\n  if ((0, _isFinite4.default)(boundaries.max)) {\n    max = boundaries.max;\n  } else if ((0, _isFinite4.default)(stats.max)) {\n    max = stats.max;\n  } else {\n    max = undefined;\n  }\n\n  return {\n    min: min !== undefined ? Math.floor(min * pow) / pow : min,\n    max: max !== undefined ? Math.ceil(max * pow) / pow : max\n  };\n}\n\nfunction getCurrentRefinement(props, searchState, currentRange, context) {\n  var refinement = (0, _indexUtils.getCurrentRefinementValue)(props, searchState, context, namespace + '.' + getId(props), {}, function (currentRefinement) {\n    var min = currentRefinement.min,\n        max = currentRefinement.max;\n\n    if (typeof min === 'string') {\n      min = parseInt(min, 10);\n    }\n\n    if (typeof max === 'string') {\n      max = parseInt(max, 10);\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  });\n  var hasMinBound = props.min !== undefined;\n  var hasMaxBound = props.max !== undefined;\n  var hasMinRefinment = refinement.min !== undefined;\n  var hasMaxRefinment = refinement.max !== undefined;\n\n  if (hasMinBound && hasMinRefinment && refinement.min < currentRange.min) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (hasMaxBound && hasMaxRefinment && refinement.max > currentRange.max) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  if (hasMinBound && !hasMinRefinment) {\n    refinement.min = currentRange.min;\n  }\n\n  if (hasMaxBound && !hasMaxRefinment) {\n    refinement.max = currentRange.max;\n  }\n\n  return refinement;\n}\n\nfunction getCurrentRefinementWithRange(refinement, range) {\n  return {\n    min: refinement.min !== undefined ? refinement.min : range.min,\n    max: refinement.max !== undefined ? refinement.max : range.max\n  };\n}\n\nfunction nextValueForRefinement(hasBound, isReset, range, value) {\n  var next = void 0;\n\n  if (!hasBound && range === value) {\n    next = undefined;\n  } else if (hasBound && isReset) {\n    next = range;\n  } else {\n    next = value;\n  }\n\n  return next;\n}\n\nfunction _refine(props, searchState, nextRefinement, currentRange, context) {\n  var nextMin = nextRefinement.min,\n      nextMax = nextRefinement.max;\n  var currentMinRange = currentRange.min,\n      currentMaxRange = currentRange.max;\n  var isMinReset = nextMin === undefined || nextMin === '';\n  var isMaxReset = nextMax === undefined || nextMax === '';\n  var nextMinAsNumber = !isMinReset ? parseFloat(nextMin) : undefined;\n  var nextMaxAsNumber = !isMaxReset ? parseFloat(nextMax) : undefined;\n  var isNextMinValid = isMinReset || (0, _isFinite4.default)(nextMinAsNumber);\n  var isNextMaxValid = isMaxReset || (0, _isFinite4.default)(nextMaxAsNumber);\n\n  if (!isNextMinValid || !isNextMaxValid) {\n    throw Error(\"You can't provide non finite values to the range connector.\");\n  }\n\n  if (nextMinAsNumber < currentMinRange) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (nextMaxAsNumber > currentMaxRange) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  var id = getId(props);\n  var resetPage = true;\n\n  var nextValue = _defineProperty({}, id, {\n    min: nextValueForRefinement(props.min !== undefined, isMinReset, currentMinRange, nextMinAsNumber),\n    max: nextValueForRefinement(props.max !== undefined, isMaxReset, currentMaxRange, nextMaxAsNumber)\n  });\n\n  return (0, _indexUtils.refineValue)(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return (0, _indexUtils.cleanUpValue)(searchState, context, namespace + '.' + getId(props));\n}\n\nexports.default = (0, _createConnector2.default)({\n  displayName: 'AlgoliaRange',\n  propTypes: {\n    id: _propTypes2.default.string,\n    attributeName: _propTypes2.default.string.isRequired,\n    defaultRefinement: _propTypes2.default.shape({\n      min: _propTypes2.default.number,\n      max: _propTypes2.default.number\n    }),\n    min: _propTypes2.default.number,\n    max: _propTypes2.default.number,\n    precision: _propTypes2.default.number\n  },\n  defaultProps: {\n    precision: 2\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var attributeName = props.attributeName,\n        precision = props.precision,\n        minBound = props.min,\n        maxBound = props.max;\n    var results = (0, _indexUtils.getResults)(searchResults, this.context);\n    var hasFacet = results && results.getFacetByName(attributeName);\n    var stats = hasFacet ? results.getFacetStats(attributeName) || {} : {};\n    var facetValues = hasFacet ? results.getFacetValues(attributeName) : [];\n    var count = facetValues.map(function (v) {\n      return {\n        value: v.name,\n        count: v.count\n      };\n    });\n\n    var _getCurrentRange = getCurrentRange({\n      min: minBound,\n      max: maxBound\n    }, stats, precision),\n        rangeMin = _getCurrentRange.min,\n        rangeMax = _getCurrentRange.max; // The searchState is not always in sync with the helper state. For example\n    // when we set boundaries on the first render the searchState don't have\n    // the correct refinement. If this behaviour change in the upcoming version\n    // we could store the range inside the searchState instead of rely on `this`.\n\n\n    this._currentRange = {\n      min: rangeMin,\n      max: rangeMax\n    };\n    var currentRefinement = getCurrentRefinement(props, searchState, this._currentRange, this.context);\n    return {\n      min: rangeMin,\n      max: rangeMax,\n      canRefine: count.length > 0,\n      currentRefinement: getCurrentRefinementWithRange(currentRefinement, this._currentRange),\n      count: count,\n      precision: precision\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, this._currentRange, this.context);\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, this.context);\n  },\n  getSearchParameters: function getSearchParameters(params, props, searchState) {\n    var attributeName = props.attributeName;\n\n    var _getCurrentRefinement = getCurrentRefinement(props, searchState, this._currentRange, this.context),\n        min = _getCurrentRefinement.min,\n        max = _getCurrentRefinement.max;\n\n    params = params.addDisjunctiveFacet(attributeName);\n\n    if (min !== undefined) {\n      params = params.addNumericRefinement(attributeName, '>=', min);\n    }\n\n    if (max !== undefined) {\n      params = params.addNumericRefinement(attributeName, '<=', max);\n    }\n\n    return params;\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var _this = this;\n\n    var _currentRange = this._currentRange,\n        minRange = _currentRange.min,\n        maxRange = _currentRange.max;\n\n    var _getCurrentRefinement2 = getCurrentRefinement(props, searchState, this._currentRange, this.context),\n        minValue = _getCurrentRefinement2.min,\n        maxValue = _getCurrentRefinement2.max;\n\n    var items = [];\n    var hasMin = minValue !== undefined;\n    var hasMax = maxValue !== undefined;\n    var shouldDisplayMinLabel = hasMin && minValue !== minRange;\n    var shouldDisplayMaxLabel = hasMax && maxValue !== maxRange;\n\n    if (shouldDisplayMinLabel || shouldDisplayMaxLabel) {\n      var fragments = [hasMin ? minValue + ' <= ' : '', props.attributeName, hasMax ? ' <= ' + maxValue : ''];\n      items.push({\n        label: fragments.join(''),\n        attributeName: props.attributeName,\n        value: function value(nextState) {\n          return _refine(props, nextState, {}, _this._currentRange, _this.context);\n        },\n        currentRefinement: getCurrentRefinementWithRange({\n          min: minValue,\n          max: maxValue\n        }, {\n          min: minRange,\n          max: maxRange\n        })\n      });\n    }\n\n    return {\n      id: getId(props),\n      index: (0, _indexUtils.getIndex)(this.context),\n      items: items\n    };\n  }\n});","map":{"version":3,"sources":["D:/TT18-EC-Team1-FE/isomorphic/node_modules/react-instantsearch/src/connectors/connectRange.js"],"names":["Object","defineProperty","exports","value","_isFinite3","require","_isFinite4","_interopRequireDefault","_propTypes","_propTypes2","_indexUtils","_createConnector","_createConnector2","obj","__esModule","default","_defineProperty","key","enumerable","configurable","writable","getId","props","attributeName","namespace","getCurrentRange","boundaries","stats","precision","pow","Math","min","undefined","max","floor","ceil","getCurrentRefinement","searchState","currentRange","context","refinement","getCurrentRefinementValue","currentRefinement","parseInt","hasMinBound","hasMaxBound","hasMinRefinment","hasMaxRefinment","Error","getCurrentRefinementWithRange","range","nextValueForRefinement","hasBound","isReset","next","_refine","nextRefinement","nextMin","nextMax","currentMinRange","currentMaxRange","isMinReset","isMaxReset","nextMinAsNumber","parseFloat","nextMaxAsNumber","isNextMinValid","isNextMaxValid","id","resetPage","nextValue","refineValue","_cleanUp","cleanUpValue","displayName","propTypes","string","isRequired","defaultRefinement","shape","number","defaultProps","getProvidedProps","searchResults","minBound","maxBound","results","getResults","hasFacet","getFacetByName","getFacetStats","facetValues","getFacetValues","count","map","v","name","_getCurrentRange","rangeMin","rangeMax","_currentRange","canRefine","length","refine","cleanUp","getSearchParameters","params","_getCurrentRefinement","addDisjunctiveFacet","addNumericRefinement","getMetadata","_this","minRange","maxRange","_getCurrentRefinement2","minValue","maxValue","items","hasMin","hasMax","shouldDisplayMinLabel","shouldDisplayMaxLabel","fragments","push","label","join","nextState","index","getIndex"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _isFinite3 = require('lodash/isFinite');\n\nvar _isFinite4 = _interopRequireDefault(_isFinite3);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _indexUtils = require('../core/indexUtils');\n\nvar _createConnector = require('../core/createConnector');\n\nvar _createConnector2 = _interopRequireDefault(_createConnector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * connectRange connector provides the logic to create connected\n * components that will give the ability for a user to refine results using\n * a numeric range.\n * @name connectRange\n * @kind connector\n * @requirements The attribute passed to the `attributeName` prop must be holding numerical values.\n * @propType {string} attributeName - Name of the attribute for faceting\n * @propType {{min?: number, max?: number}} [defaultRefinement] - Default searchState of the widget containing the start and the end of the range.\n * @propType {number} [min] - Minimum value. When this isn't set, the minimum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [max] - Maximum value. When this isn't set, the maximum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [precision=2] - Number of digits after decimal point to use.\n * @providedPropType {function} refine - a function to select a range.\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n * @providedPropType {number} min - the minimum value available.\n * @providedPropType {number} max - the maximum value available.\n * @providedPropType {number} precision - Number of digits after decimal point to use.\n */\n\nfunction getId(props) {\n  return props.attributeName;\n}\n\nvar namespace = 'range';\n\nfunction getCurrentRange(boundaries, stats, precision) {\n  var pow = Math.pow(10, precision);\n\n  var min = void 0;\n  if ((0, _isFinite4.default)(boundaries.min)) {\n    min = boundaries.min;\n  } else if ((0, _isFinite4.default)(stats.min)) {\n    min = stats.min;\n  } else {\n    min = undefined;\n  }\n\n  var max = void 0;\n  if ((0, _isFinite4.default)(boundaries.max)) {\n    max = boundaries.max;\n  } else if ((0, _isFinite4.default)(stats.max)) {\n    max = stats.max;\n  } else {\n    max = undefined;\n  }\n\n  return {\n    min: min !== undefined ? Math.floor(min * pow) / pow : min,\n    max: max !== undefined ? Math.ceil(max * pow) / pow : max\n  };\n}\n\nfunction getCurrentRefinement(props, searchState, currentRange, context) {\n  var refinement = (0, _indexUtils.getCurrentRefinementValue)(props, searchState, context, namespace + '.' + getId(props), {}, function (currentRefinement) {\n    var min = currentRefinement.min,\n        max = currentRefinement.max;\n\n    if (typeof min === 'string') {\n      min = parseInt(min, 10);\n    }\n    if (typeof max === 'string') {\n      max = parseInt(max, 10);\n    }\n    return { min: min, max: max };\n  });\n\n  var hasMinBound = props.min !== undefined;\n  var hasMaxBound = props.max !== undefined;\n\n  var hasMinRefinment = refinement.min !== undefined;\n  var hasMaxRefinment = refinement.max !== undefined;\n\n  if (hasMinBound && hasMinRefinment && refinement.min < currentRange.min) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (hasMaxBound && hasMaxRefinment && refinement.max > currentRange.max) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  if (hasMinBound && !hasMinRefinment) {\n    refinement.min = currentRange.min;\n  }\n\n  if (hasMaxBound && !hasMaxRefinment) {\n    refinement.max = currentRange.max;\n  }\n\n  return refinement;\n}\n\nfunction getCurrentRefinementWithRange(refinement, range) {\n  return {\n    min: refinement.min !== undefined ? refinement.min : range.min,\n    max: refinement.max !== undefined ? refinement.max : range.max\n  };\n}\n\nfunction nextValueForRefinement(hasBound, isReset, range, value) {\n  var next = void 0;\n  if (!hasBound && range === value) {\n    next = undefined;\n  } else if (hasBound && isReset) {\n    next = range;\n  } else {\n    next = value;\n  }\n\n  return next;\n}\n\nfunction _refine(props, searchState, nextRefinement, currentRange, context) {\n  var nextMin = nextRefinement.min,\n      nextMax = nextRefinement.max;\n  var currentMinRange = currentRange.min,\n      currentMaxRange = currentRange.max;\n\n\n  var isMinReset = nextMin === undefined || nextMin === '';\n  var isMaxReset = nextMax === undefined || nextMax === '';\n\n  var nextMinAsNumber = !isMinReset ? parseFloat(nextMin) : undefined;\n  var nextMaxAsNumber = !isMaxReset ? parseFloat(nextMax) : undefined;\n\n  var isNextMinValid = isMinReset || (0, _isFinite4.default)(nextMinAsNumber);\n  var isNextMaxValid = isMaxReset || (0, _isFinite4.default)(nextMaxAsNumber);\n\n  if (!isNextMinValid || !isNextMaxValid) {\n    throw Error(\"You can't provide non finite values to the range connector.\");\n  }\n\n  if (nextMinAsNumber < currentMinRange) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (nextMaxAsNumber > currentMaxRange) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  var id = getId(props);\n  var resetPage = true;\n  var nextValue = _defineProperty({}, id, {\n    min: nextValueForRefinement(props.min !== undefined, isMinReset, currentMinRange, nextMinAsNumber),\n    max: nextValueForRefinement(props.max !== undefined, isMaxReset, currentMaxRange, nextMaxAsNumber)\n  });\n\n  return (0, _indexUtils.refineValue)(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return (0, _indexUtils.cleanUpValue)(searchState, context, namespace + '.' + getId(props));\n}\n\nexports.default = (0, _createConnector2.default)({\n  displayName: 'AlgoliaRange',\n\n  propTypes: {\n    id: _propTypes2.default.string,\n    attributeName: _propTypes2.default.string.isRequired,\n    defaultRefinement: _propTypes2.default.shape({\n      min: _propTypes2.default.number,\n      max: _propTypes2.default.number\n    }),\n    min: _propTypes2.default.number,\n    max: _propTypes2.default.number,\n    precision: _propTypes2.default.number\n  },\n\n  defaultProps: {\n    precision: 2\n  },\n\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var attributeName = props.attributeName,\n        precision = props.precision,\n        minBound = props.min,\n        maxBound = props.max;\n\n    var results = (0, _indexUtils.getResults)(searchResults, this.context);\n    var hasFacet = results && results.getFacetByName(attributeName);\n    var stats = hasFacet ? results.getFacetStats(attributeName) || {} : {};\n    var facetValues = hasFacet ? results.getFacetValues(attributeName) : [];\n\n    var count = facetValues.map(function (v) {\n      return {\n        value: v.name,\n        count: v.count\n      };\n    });\n\n    var _getCurrentRange = getCurrentRange({ min: minBound, max: maxBound }, stats, precision),\n        rangeMin = _getCurrentRange.min,\n        rangeMax = _getCurrentRange.max;\n\n    // The searchState is not always in sync with the helper state. For example\n    // when we set boundaries on the first render the searchState don't have\n    // the correct refinement. If this behaviour change in the upcoming version\n    // we could store the range inside the searchState instead of rely on `this`.\n\n\n    this._currentRange = {\n      min: rangeMin,\n      max: rangeMax\n    };\n\n    var currentRefinement = getCurrentRefinement(props, searchState, this._currentRange, this.context);\n\n    return {\n      min: rangeMin,\n      max: rangeMax,\n      canRefine: count.length > 0,\n      currentRefinement: getCurrentRefinementWithRange(currentRefinement, this._currentRange),\n      count: count,\n      precision: precision\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, this._currentRange, this.context);\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, this.context);\n  },\n  getSearchParameters: function getSearchParameters(params, props, searchState) {\n    var attributeName = props.attributeName;\n\n    var _getCurrentRefinement = getCurrentRefinement(props, searchState, this._currentRange, this.context),\n        min = _getCurrentRefinement.min,\n        max = _getCurrentRefinement.max;\n\n    params = params.addDisjunctiveFacet(attributeName);\n\n    if (min !== undefined) {\n      params = params.addNumericRefinement(attributeName, '>=', min);\n    }\n\n    if (max !== undefined) {\n      params = params.addNumericRefinement(attributeName, '<=', max);\n    }\n\n    return params;\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var _this = this;\n\n    var _currentRange = this._currentRange,\n        minRange = _currentRange.min,\n        maxRange = _currentRange.max;\n\n    var _getCurrentRefinement2 = getCurrentRefinement(props, searchState, this._currentRange, this.context),\n        minValue = _getCurrentRefinement2.min,\n        maxValue = _getCurrentRefinement2.max;\n\n    var items = [];\n    var hasMin = minValue !== undefined;\n    var hasMax = maxValue !== undefined;\n    var shouldDisplayMinLabel = hasMin && minValue !== minRange;\n    var shouldDisplayMaxLabel = hasMax && maxValue !== maxRange;\n\n    if (shouldDisplayMinLabel || shouldDisplayMaxLabel) {\n      var fragments = [hasMin ? minValue + ' <= ' : '', props.attributeName, hasMax ? ' <= ' + maxValue : ''];\n\n      items.push({\n        label: fragments.join(''),\n        attributeName: props.attributeName,\n        value: function value(nextState) {\n          return _refine(props, nextState, {}, _this._currentRange, _this.context);\n        },\n        currentRefinement: getCurrentRefinementWithRange({ min: minValue, max: maxValue }, { min: minRange, max: maxRange })\n      });\n    }\n\n    return {\n      id: getId(props),\n      index: (0, _indexUtils.getIndex)(this.context),\n      items: items\n    };\n  }\n});"]},"metadata":{},"sourceType":"script"}