{"ast":null,"code":"var toArray = require('../../../toArray');\n\nvar getRelativePath = require('./getRelativePath');\n\nvar getFilesAndDirectoriesFromDirectory = require('./getFilesAndDirectoriesFromDirectory');\n\nmodule.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {\n  var files = [];\n  var rootPromises = [];\n  /**\n   * Returns a resolved promise, when :files array is enhanced\n   *\n   * @param {(FileSystemFileEntry|FileSystemDirectoryEntry)} entry\n   * @returns {Promise} - empty promise that resolves when :files is enhanced with a file\n   */\n\n  var createPromiseToAddFileOrParseDirectory = function createPromiseToAddFileOrParseDirectory(entry) {\n    return new Promise(function (resolve) {\n      // This is a base call\n      if (entry.isFile) {\n        // Creates a new File object which can be used to read the file.\n        entry.file(function (file) {\n          file.relativePath = getRelativePath(entry);\n          files.push(file);\n          resolve();\n        }, // Make sure we resolve on error anyway, it's fine if only one file couldn't be read!\n        function (error) {\n          logDropError(error);\n          resolve();\n        }); // This is a recursive call\n      } else if (entry.isDirectory) {\n        var directoryReader = entry.createReader();\n        getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {\n          onSuccess: function onSuccess(entries) {\n            var promises = entries.map(function (entry) {\n              return createPromiseToAddFileOrParseDirectory(entry);\n            });\n            Promise.all(promises).then(function () {\n              return resolve();\n            });\n          }\n        });\n      }\n    });\n  }; // For each dropped item, - make sure it's a file/directory, and start deepening in!\n\n\n  toArray(dataTransfer.items).forEach(function (item) {\n    var entry = item.webkitGetAsEntry(); // :entry can be null when we drop the url e.g.\n\n    if (entry) {\n      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));\n    }\n  });\n  return Promise.all(rootPromises).then(function () {\n    return files;\n  });\n};","map":{"version":3,"sources":["D:/TT18-EC-Team1-FE/isomorphic/node_modules/@uppy/utils/lib/getDroppedFiles/utils/webkitGetAsEntryApi/index.js"],"names":["toArray","require","getRelativePath","getFilesAndDirectoriesFromDirectory","module","exports","webkitGetAsEntryApi","dataTransfer","logDropError","files","rootPromises","createPromiseToAddFileOrParseDirectory","entry","Promise","resolve","isFile","file","relativePath","push","error","isDirectory","directoryReader","createReader","onSuccess","entries","promises","map","all","then","items","forEach","item","webkitGetAsEntry"],"mappings":"AAAA,IAAIA,OAAO,GAAGC,OAAO,CAAC,kBAAD,CAArB;;AAEA,IAAIC,eAAe,GAAGD,OAAO,CAAC,mBAAD,CAA7B;;AAEA,IAAIE,mCAAmC,GAAGF,OAAO,CAAC,uCAAD,CAAjD;;AAEAG,MAAM,CAACC,OAAP,GAAiB,SAASC,mBAAT,CAA6BC,YAA7B,EAA2CC,YAA3C,EAAyD;AACxE,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,YAAY,GAAG,EAAnB;AACA;AACF;AACA;AACA;AACA;AACA;;AAEE,MAAIC,sCAAsC,GAAG,SAASA,sCAAT,CAAgDC,KAAhD,EAAuD;AAClG,WAAO,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmB;AACpC;AACA,UAAIF,KAAK,CAACG,MAAV,EAAkB;AAChB;AACAH,QAAAA,KAAK,CAACI,IAAN,CAAW,UAAUA,IAAV,EAAgB;AACzBA,UAAAA,IAAI,CAACC,YAAL,GAAoBf,eAAe,CAACU,KAAD,CAAnC;AACAH,UAAAA,KAAK,CAACS,IAAN,CAAWF,IAAX;AACAF,UAAAA,OAAO;AACR,SAJD,EAIG;AACH,kBAAUK,KAAV,EAAiB;AACfX,UAAAA,YAAY,CAACW,KAAD,CAAZ;AACAL,UAAAA,OAAO;AACR,SARD,EAFgB,CAUZ;AACL,OAXD,MAWO,IAAIF,KAAK,CAACQ,WAAV,EAAuB;AAC5B,YAAIC,eAAe,GAAGT,KAAK,CAACU,YAAN,EAAtB;AACAnB,QAAAA,mCAAmC,CAACkB,eAAD,EAAkB,EAAlB,EAAsBb,YAAtB,EAAoC;AACrEe,UAAAA,SAAS,EAAE,SAASA,SAAT,CAAmBC,OAAnB,EAA4B;AACrC,gBAAIC,QAAQ,GAAGD,OAAO,CAACE,GAAR,CAAY,UAAUd,KAAV,EAAiB;AAC1C,qBAAOD,sCAAsC,CAACC,KAAD,CAA7C;AACD,aAFc,CAAf;AAGAC,YAAAA,OAAO,CAACc,GAAR,CAAYF,QAAZ,EAAsBG,IAAtB,CAA2B,YAAY;AACrC,qBAAOd,OAAO,EAAd;AACD,aAFD;AAGD;AARoE,SAApC,CAAnC;AAUD;AACF,KA1BM,CAAP;AA2BD,GA5BD,CAVwE,CAsCrE;;;AAGHd,EAAAA,OAAO,CAACO,YAAY,CAACsB,KAAd,CAAP,CAA4BC,OAA5B,CAAoC,UAAUC,IAAV,EAAgB;AAClD,QAAInB,KAAK,GAAGmB,IAAI,CAACC,gBAAL,EAAZ,CADkD,CACb;;AAErC,QAAIpB,KAAJ,EAAW;AACTF,MAAAA,YAAY,CAACQ,IAAb,CAAkBP,sCAAsC,CAACC,KAAD,CAAxD;AACD;AACF,GAND;AAOA,SAAOC,OAAO,CAACc,GAAR,CAAYjB,YAAZ,EAA0BkB,IAA1B,CAA+B,YAAY;AAChD,WAAOnB,KAAP;AACD,GAFM,CAAP;AAGD,CAnDD","sourcesContent":["var toArray = require('../../../toArray');\n\nvar getRelativePath = require('./getRelativePath');\n\nvar getFilesAndDirectoriesFromDirectory = require('./getFilesAndDirectoriesFromDirectory');\n\nmodule.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {\n  var files = [];\n  var rootPromises = [];\n  /**\n   * Returns a resolved promise, when :files array is enhanced\n   *\n   * @param {(FileSystemFileEntry|FileSystemDirectoryEntry)} entry\n   * @returns {Promise} - empty promise that resolves when :files is enhanced with a file\n   */\n\n  var createPromiseToAddFileOrParseDirectory = function createPromiseToAddFileOrParseDirectory(entry) {\n    return new Promise(function (resolve) {\n      // This is a base call\n      if (entry.isFile) {\n        // Creates a new File object which can be used to read the file.\n        entry.file(function (file) {\n          file.relativePath = getRelativePath(entry);\n          files.push(file);\n          resolve();\n        }, // Make sure we resolve on error anyway, it's fine if only one file couldn't be read!\n        function (error) {\n          logDropError(error);\n          resolve();\n        }); // This is a recursive call\n      } else if (entry.isDirectory) {\n        var directoryReader = entry.createReader();\n        getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {\n          onSuccess: function onSuccess(entries) {\n            var promises = entries.map(function (entry) {\n              return createPromiseToAddFileOrParseDirectory(entry);\n            });\n            Promise.all(promises).then(function () {\n              return resolve();\n            });\n          }\n        });\n      }\n    });\n  }; // For each dropped item, - make sure it's a file/directory, and start deepening in!\n\n\n  toArray(dataTransfer.items).forEach(function (item) {\n    var entry = item.webkitGetAsEntry(); // :entry can be null when we drop the url e.g.\n\n    if (entry) {\n      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));\n    }\n  });\n  return Promise.all(rootPromises).then(function () {\n    return files;\n  });\n};"]},"metadata":{},"sourceType":"script"}