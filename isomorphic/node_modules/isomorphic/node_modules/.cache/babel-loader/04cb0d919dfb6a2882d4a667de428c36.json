{"ast":null,"code":"var findIndex = require('./findIndex');\n\nfunction createCancelError() {\n  return new Error('Cancelled');\n}\n\nmodule.exports = /*#__PURE__*/function () {\n  function RateLimitedQueue(limit) {\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity;\n    } else {\n      this.limit = limit;\n    }\n\n    this.activeRequests = 0;\n    this.queuedHandlers = [];\n  }\n\n  var _proto = RateLimitedQueue.prototype;\n\n  _proto._call = function _call(fn) {\n    var _this = this;\n\n    this.activeRequests += 1;\n    var _done = false;\n    var cancelActive;\n\n    try {\n      cancelActive = fn();\n    } catch (err) {\n      this.activeRequests -= 1;\n      throw err;\n    }\n\n    return {\n      abort: function abort() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n        cancelActive();\n\n        _this._queueNext();\n      },\n      done: function done() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n\n        _this._queueNext();\n      }\n    };\n  };\n\n  _proto._queueNext = function _queueNext() {\n    var _this2 = this; // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n    // one by one without continuously _advancing_ it (and starting new tasks before immediately\n    // aborting them)\n\n\n    Promise.resolve().then(function () {\n      _this2._next();\n    });\n  };\n\n  _proto._next = function _next() {\n    if (this.activeRequests >= this.limit) {\n      return;\n    }\n\n    if (this.queuedHandlers.length === 0) {\n      return;\n    } // Dispatch the next request, and update the abort/done handlers\n    // so that cancelling it does the Right Thing (and doesn't just try\n    // to dequeue an already-running request).\n\n\n    var next = this.queuedHandlers.shift();\n\n    var handler = this._call(next.fn);\n\n    next.abort = handler.abort;\n    next.done = handler.done;\n  };\n\n  _proto._queue = function _queue(fn, options) {\n    var _this3 = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var handler = {\n      fn: fn,\n      priority: options.priority || 0,\n      abort: function abort() {\n        _this3._dequeue(handler);\n      },\n      done: function done() {\n        throw new Error('Cannot mark a queued request as done: this indicates a bug');\n      }\n    };\n    var index = findIndex(this.queuedHandlers, function (other) {\n      return handler.priority > other.priority;\n    });\n\n    if (index === -1) {\n      this.queuedHandlers.push(handler);\n    } else {\n      this.queuedHandlers.splice(index, 0, handler);\n    }\n\n    return handler;\n  };\n\n  _proto._dequeue = function _dequeue(handler) {\n    var index = this.queuedHandlers.indexOf(handler);\n\n    if (index !== -1) {\n      this.queuedHandlers.splice(index, 1);\n    }\n  };\n\n  _proto.run = function run(fn, queueOptions) {\n    if (this.activeRequests < this.limit) {\n      return this._call(fn);\n    }\n\n    return this._queue(fn, queueOptions);\n  };\n\n  _proto.wrapPromiseFunction = function wrapPromiseFunction(fn, queueOptions) {\n    var _this4 = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var queuedRequest;\n      var outerPromise = new Promise(function (resolve, reject) {\n        queuedRequest = _this4.run(function () {\n          var cancelError;\n          var innerPromise;\n\n          try {\n            innerPromise = Promise.resolve(fn.apply(void 0, args));\n          } catch (err) {\n            innerPromise = Promise.reject(err);\n          }\n\n          innerPromise.then(function (result) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              resolve(result);\n            }\n          }, function (err) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              reject(err);\n            }\n          });\n          return function () {\n            cancelError = createCancelError();\n          };\n        }, queueOptions);\n      });\n\n      outerPromise.abort = function () {\n        queuedRequest.abort();\n      };\n\n      return outerPromise;\n    };\n  };\n\n  return RateLimitedQueue;\n}();","map":{"version":3,"sources":["D:/TT18-EC-Team1-FE/isomorphic/node_modules/@uppy/utils/lib/RateLimitedQueue.js"],"names":["findIndex","require","createCancelError","Error","module","exports","RateLimitedQueue","limit","Infinity","activeRequests","queuedHandlers","_proto","prototype","_call","fn","_this","_done","cancelActive","err","abort","_queueNext","done","_this2","Promise","resolve","then","_next","length","next","shift","handler","_queue","options","_this3","priority","_dequeue","index","other","push","splice","indexOf","run","queueOptions","wrapPromiseFunction","_this4","_len","arguments","args","Array","_key","queuedRequest","outerPromise","reject","cancelError","innerPromise","apply","result"],"mappings":"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","sourcesContent":["var findIndex = require('./findIndex');\n\nfunction createCancelError() {\n  return new Error('Cancelled');\n}\n\nmodule.exports = /*#__PURE__*/function () {\n  function RateLimitedQueue(limit) {\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity;\n    } else {\n      this.limit = limit;\n    }\n\n    this.activeRequests = 0;\n    this.queuedHandlers = [];\n  }\n\n  var _proto = RateLimitedQueue.prototype;\n\n  _proto._call = function _call(fn) {\n    var _this = this;\n\n    this.activeRequests += 1;\n    var _done = false;\n    var cancelActive;\n\n    try {\n      cancelActive = fn();\n    } catch (err) {\n      this.activeRequests -= 1;\n      throw err;\n    }\n\n    return {\n      abort: function abort() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n        cancelActive();\n\n        _this._queueNext();\n      },\n      done: function done() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n\n        _this._queueNext();\n      }\n    };\n  };\n\n  _proto._queueNext = function _queueNext() {\n    var _this2 = this;\n\n    // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n    // one by one without continuously _advancing_ it (and starting new tasks before immediately\n    // aborting them)\n    Promise.resolve().then(function () {\n      _this2._next();\n    });\n  };\n\n  _proto._next = function _next() {\n    if (this.activeRequests >= this.limit) {\n      return;\n    }\n\n    if (this.queuedHandlers.length === 0) {\n      return;\n    } // Dispatch the next request, and update the abort/done handlers\n    // so that cancelling it does the Right Thing (and doesn't just try\n    // to dequeue an already-running request).\n\n\n    var next = this.queuedHandlers.shift();\n\n    var handler = this._call(next.fn);\n\n    next.abort = handler.abort;\n    next.done = handler.done;\n  };\n\n  _proto._queue = function _queue(fn, options) {\n    var _this3 = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var handler = {\n      fn: fn,\n      priority: options.priority || 0,\n      abort: function abort() {\n        _this3._dequeue(handler);\n      },\n      done: function done() {\n        throw new Error('Cannot mark a queued request as done: this indicates a bug');\n      }\n    };\n    var index = findIndex(this.queuedHandlers, function (other) {\n      return handler.priority > other.priority;\n    });\n\n    if (index === -1) {\n      this.queuedHandlers.push(handler);\n    } else {\n      this.queuedHandlers.splice(index, 0, handler);\n    }\n\n    return handler;\n  };\n\n  _proto._dequeue = function _dequeue(handler) {\n    var index = this.queuedHandlers.indexOf(handler);\n\n    if (index !== -1) {\n      this.queuedHandlers.splice(index, 1);\n    }\n  };\n\n  _proto.run = function run(fn, queueOptions) {\n    if (this.activeRequests < this.limit) {\n      return this._call(fn);\n    }\n\n    return this._queue(fn, queueOptions);\n  };\n\n  _proto.wrapPromiseFunction = function wrapPromiseFunction(fn, queueOptions) {\n    var _this4 = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var queuedRequest;\n      var outerPromise = new Promise(function (resolve, reject) {\n        queuedRequest = _this4.run(function () {\n          var cancelError;\n          var innerPromise;\n\n          try {\n            innerPromise = Promise.resolve(fn.apply(void 0, args));\n          } catch (err) {\n            innerPromise = Promise.reject(err);\n          }\n\n          innerPromise.then(function (result) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              resolve(result);\n            }\n          }, function (err) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              reject(err);\n            }\n          });\n          return function () {\n            cancelError = createCancelError();\n          };\n        }, queueOptions);\n      });\n\n      outerPromise.abort = function () {\n        queuedRequest.abort();\n      };\n\n      return outerPromise;\n    };\n  };\n\n  return RateLimitedQueue;\n}();"]},"metadata":{},"sourceType":"script"}