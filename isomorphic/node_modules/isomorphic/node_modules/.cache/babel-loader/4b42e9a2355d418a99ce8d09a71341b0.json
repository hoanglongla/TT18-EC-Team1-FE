{"ast":null,"code":"'use strict';\n\nmodule.exports = generateTrees;\n\nvar last = require('lodash/last');\n\nvar map = require('lodash/map');\n\nvar reduce = require('lodash/reduce');\n\nvar orderBy = require('lodash/orderBy');\n\nvar trim = require('lodash/trim');\n\nvar find = require('lodash/find');\n\nvar pickBy = require('lodash/pickBy');\n\nvar prepareHierarchicalFacetSortBy = require('../functions/formatSort');\n\nfunction generateTrees(state) {\n  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {\n    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];\n    var hierarchicalFacetRefinement = state.hierarchicalFacetsRefinements[hierarchicalFacet.name] && state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0] || '';\n\n    var hierarchicalSeparator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n    var hierarchicalRootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n\n    var hierarchicalShowParentLevel = state._getHierarchicalShowParentLevel(hierarchicalFacet);\n\n    var sortBy = prepareHierarchicalFacetSortBy(state._getHierarchicalFacetSortBy(hierarchicalFacet));\n    var generateTreeFn = generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel, hierarchicalFacetRefinement);\n    var results = hierarchicalFacetResult;\n\n    if (hierarchicalRootPath) {\n      results = hierarchicalFacetResult.slice(hierarchicalRootPath.split(hierarchicalSeparator).length);\n    }\n\n    return reduce(results, generateTreeFn, {\n      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,\n      count: null,\n      // root level, no count\n      isRefined: true,\n      // root level, always refined\n      path: null,\n      // root level, no path\n      data: null\n    });\n  };\n}\n\nfunction generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel, currentRefinement) {\n  return function generateTree(hierarchicalTree, hierarchicalFacetResult, currentHierarchicalLevel) {\n    var parent = hierarchicalTree;\n\n    if (currentHierarchicalLevel > 0) {\n      var level = 0;\n      parent = hierarchicalTree;\n\n      while (level < currentHierarchicalLevel) {\n        parent = parent && find(parent.data, {\n          isRefined: true\n        });\n        level++;\n      }\n    } // we found a refined parent, let's add current level data under it\n\n\n    if (parent) {\n      // filter values in case an object has multiple categories:\n      //   {\n      //     categories: {\n      //       level0: ['beers', 'bières'],\n      //       level1: ['beers > IPA', 'bières > Belges']\n      //     }\n      //   }\n      //\n      // If parent refinement is `beers`, then we do not want to have `bières > Belges`\n      // showing up\n      var onlyMatchingValuesFn = filterFacetValues(parent.path || hierarchicalRootPath, currentRefinement, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel);\n      parent.data = orderBy(map(pickBy(hierarchicalFacetResult.data, onlyMatchingValuesFn), formatHierarchicalFacetValue(hierarchicalSeparator, currentRefinement)), sortBy[0], sortBy[1]);\n    }\n\n    return hierarchicalTree;\n  };\n}\n\nfunction filterFacetValues(parentPath, currentRefinement, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel) {\n  return function (facetCount, facetValue) {\n    // we want the facetValue is a child of hierarchicalRootPath\n    if (hierarchicalRootPath && (facetValue.indexOf(hierarchicalRootPath) !== 0 || hierarchicalRootPath === facetValue)) {\n      return false;\n    } // we always want root levels (only when there is no prefix path)\n\n\n    return !hierarchicalRootPath && facetValue.indexOf(hierarchicalSeparator) === -1 || // if there is a rootPath, being root level mean 1 level under rootPath\n    hierarchicalRootPath && facetValue.split(hierarchicalSeparator).length - hierarchicalRootPath.split(hierarchicalSeparator).length === 1 || // if current refinement is a root level and current facetValue is a root level,\n    // keep the facetValue\n    facetValue.indexOf(hierarchicalSeparator) === -1 && currentRefinement.indexOf(hierarchicalSeparator) === -1 || // currentRefinement is a child of the facet value\n    currentRefinement.indexOf(facetValue) === 0 || // facetValue is a child of the current parent, add it\n    facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 && (hierarchicalShowParentLevel || facetValue.indexOf(currentRefinement) === 0);\n  };\n}\n\nfunction formatHierarchicalFacetValue(hierarchicalSeparator, currentRefinement) {\n  return function format(facetCount, facetValue) {\n    return {\n      name: trim(last(facetValue.split(hierarchicalSeparator))),\n      path: facetValue,\n      count: facetCount,\n      isRefined: currentRefinement === facetValue || currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,\n      data: null\n    };\n  };\n}","map":{"version":3,"sources":["D:/Team6-FE/isomorphic/node_modules/algoliasearch-helper/src/SearchResults/generate-hierarchical-tree.js"],"names":["module","exports","generateTrees","last","require","map","reduce","orderBy","trim","find","pickBy","prepareHierarchicalFacetSortBy","state","generate","hierarchicalFacetResult","hierarchicalFacetIndex","hierarchicalFacet","hierarchicalFacets","hierarchicalFacetRefinement","hierarchicalFacetsRefinements","name","hierarchicalSeparator","_getHierarchicalFacetSeparator","hierarchicalRootPath","_getHierarchicalRootPath","hierarchicalShowParentLevel","_getHierarchicalShowParentLevel","sortBy","_getHierarchicalFacetSortBy","generateTreeFn","generateHierarchicalTree","results","slice","split","length","count","isRefined","path","data","currentRefinement","generateTree","hierarchicalTree","currentHierarchicalLevel","parent","level","onlyMatchingValuesFn","filterFacetValues","formatHierarchicalFacetValue","parentPath","facetCount","facetValue","indexOf","format"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = generateTrees;\n\nvar last = require('lodash/last');\nvar map = require('lodash/map');\nvar reduce = require('lodash/reduce');\nvar orderBy = require('lodash/orderBy');\nvar trim = require('lodash/trim');\nvar find = require('lodash/find');\nvar pickBy = require('lodash/pickBy');\n\nvar prepareHierarchicalFacetSortBy = require('../functions/formatSort');\n\nfunction generateTrees(state) {\n  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {\n    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];\n    var hierarchicalFacetRefinement = state.hierarchicalFacetsRefinements[hierarchicalFacet.name] &&\n      state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0] || '';\n    var hierarchicalSeparator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n    var hierarchicalRootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n    var hierarchicalShowParentLevel = state._getHierarchicalShowParentLevel(hierarchicalFacet);\n    var sortBy = prepareHierarchicalFacetSortBy(state._getHierarchicalFacetSortBy(hierarchicalFacet));\n\n    var generateTreeFn = generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath,\n      hierarchicalShowParentLevel, hierarchicalFacetRefinement);\n\n    var results = hierarchicalFacetResult;\n\n    if (hierarchicalRootPath) {\n      results = hierarchicalFacetResult.slice(hierarchicalRootPath.split(hierarchicalSeparator).length);\n    }\n\n    return reduce(results, generateTreeFn, {\n      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,\n      count: null, // root level, no count\n      isRefined: true, // root level, always refined\n      path: null, // root level, no path\n      data: null\n    });\n  };\n}\n\nfunction generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath,\n                                  hierarchicalShowParentLevel, currentRefinement) {\n  return function generateTree(hierarchicalTree, hierarchicalFacetResult, currentHierarchicalLevel) {\n    var parent = hierarchicalTree;\n\n    if (currentHierarchicalLevel > 0) {\n      var level = 0;\n\n      parent = hierarchicalTree;\n\n      while (level < currentHierarchicalLevel) {\n        parent = parent && find(parent.data, {isRefined: true});\n        level++;\n      }\n    }\n\n    // we found a refined parent, let's add current level data under it\n    if (parent) {\n      // filter values in case an object has multiple categories:\n      //   {\n      //     categories: {\n      //       level0: ['beers', 'bières'],\n      //       level1: ['beers > IPA', 'bières > Belges']\n      //     }\n      //   }\n      //\n      // If parent refinement is `beers`, then we do not want to have `bières > Belges`\n      // showing up\n\n      var onlyMatchingValuesFn = filterFacetValues(parent.path || hierarchicalRootPath,\n        currentRefinement, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel);\n\n      parent.data = orderBy(\n        map(\n          pickBy(hierarchicalFacetResult.data, onlyMatchingValuesFn),\n          formatHierarchicalFacetValue(hierarchicalSeparator, currentRefinement)\n        ),\n        sortBy[0], sortBy[1]\n      );\n    }\n\n    return hierarchicalTree;\n  };\n}\n\nfunction filterFacetValues(parentPath, currentRefinement, hierarchicalSeparator, hierarchicalRootPath,\n                           hierarchicalShowParentLevel) {\n  return function(facetCount, facetValue) {\n    // we want the facetValue is a child of hierarchicalRootPath\n    if (hierarchicalRootPath &&\n      (facetValue.indexOf(hierarchicalRootPath) !== 0 || hierarchicalRootPath === facetValue)) {\n      return false;\n    }\n\n    // we always want root levels (only when there is no prefix path)\n    return !hierarchicalRootPath && facetValue.indexOf(hierarchicalSeparator) === -1 ||\n      // if there is a rootPath, being root level mean 1 level under rootPath\n      hierarchicalRootPath &&\n      facetValue.split(hierarchicalSeparator).length - hierarchicalRootPath.split(hierarchicalSeparator).length === 1 ||\n      // if current refinement is a root level and current facetValue is a root level,\n      // keep the facetValue\n      facetValue.indexOf(hierarchicalSeparator) === -1 &&\n      currentRefinement.indexOf(hierarchicalSeparator) === -1 ||\n      // currentRefinement is a child of the facet value\n      currentRefinement.indexOf(facetValue) === 0 ||\n      // facetValue is a child of the current parent, add it\n      facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 &&\n      (hierarchicalShowParentLevel || facetValue.indexOf(currentRefinement) === 0);\n  };\n}\n\nfunction formatHierarchicalFacetValue(hierarchicalSeparator, currentRefinement) {\n  return function format(facetCount, facetValue) {\n    return {\n      name: trim(last(facetValue.split(hierarchicalSeparator))),\n      path: facetValue,\n      count: facetCount,\n      isRefined: currentRefinement === facetValue || currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,\n      data: null\n    };\n  };\n}\n"]},"metadata":{},"sourceType":"script"}